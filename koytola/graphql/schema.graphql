# Anything
scalar _Any

union _Entity =
    Address
  | User
  | Group
  | App
  | Product
  | Category
  | Brochure
  | Video
  | SocialResponsibility
  | Contact
  | Company
type _Service {
  sdl: String
}

# Create a new address for the account.
type AccountAddressCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A user instance for which the address was created.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

# Delete an address of the logged-in user.
type AccountAddressDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A user instance for which the address was deleted.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

# Updates an address of the logged-in user.
type AccountAddressUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A user object for which the address was edited.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

# Deletes accounts.
type AccountBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  accountErrors: [AccountError!]!
}

# Creates a new account.
type AccountCreatebyStaff {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Deletes an account.
type AccountDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Remove user account by the request.
type AccountDeletebyRequest {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Deletes an account.
type AccountDeletebyStaff {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
  user: User
}

type AccountError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: AccountErrorCode!
}

# An enumeration.
enum AccountErrorCode {
  ACTIVATE_OWN_ACCOUNT
  ACTIVATE_SUPERUSER_ACCOUNT
  DUPLICATED_INPUT_ITEM
  DEACTIVATE_OWN_ACCOUNT
  DEACTIVATE_SUPERUSER_ACCOUNT
  DELETE_NON_STAFF_USER
  DELETE_OWN_ACCOUNT
  DELETE_STAFF_ACCOUNT
  DELETE_SUPERUSER_ACCOUNT
  EMAIL_ALREADY_USED
  GRAPHQL_ERROR
  INVALID
  INVALID_PASSWORD
  LEFT_NOT_MANAGEABLE_PERMISSION
  INVALID_CREDENTIALS
  NOT_FOUND
  OUT_OF_SCOPE_SERVICE_ACCOUNT
  OUT_OF_SCOPE_USER
  OUT_OF_SCOPE_GROUP
  OUT_OF_SCOPE_PERMISSION
  PASSWORD_NOT_CORRECT
  PASSWORD_ENTIRELY_NUMERIC
  PASSWORD_TOO_COMMON
  PASSWORD_TOO_SHORT
  PASSWORD_TOO_SIMILAR
  REQUIRED
  UNIQUE
  JWT_SIGNATURE_EXPIRED
  JWT_INVALID_TOKEN
  JWT_DECODE_ERROR
  JWT_MISSING_TOKEN
  JWT_INVALID_CSRF_TOKEN
}

# History log of the customer.
type AccountEvent implements Node {
  # The ID of the object.
  id: ID!
  # Date when event happened at in ISO 8601 format.
  date: DateTime
  # Account event type.
  type: AccountEventsEnum
  # User who performed the action.
  user: User
  # The concerned order.
  order: Order
}

# An enumeration.
enum AccountEventsEnum {
  ACCOUNT_CREATED
  ACCOUNT_DELETED
  ACCOUNT_UPDATED
  PASSWORD_RESET_LINK_SENT
  PASSWORD_RESET
  EMAIL_CHANGED_REQUEST
  PASSWORD_CHANGED
  EMAIL_CHANGED
  ACCOUNT_ACTIVATED_BY_STAFF
  ACCOUNT_DEACTIVATED_BY_STAFF
  ACCOUNT_CREATED_BY_STAFF
  ACCOUNT_DELETED_BY_STAFF
  EMAIL_ASSIGNED_BY_STAFF
  EMAIL_UPDATED_BY_STAFF
  NAME_ASSIGNED_BY_STAFF
  NOTE_ADDED_BY_STAFF
  PLACED_ORDER
  ORDER_UPDATE
  NOTE_ADDED_TO_ORDER
  DIGITAL_LINK_DOWNLOADED
  PROFILE_CREATED
  PROFILE_UPDATED
  PROFILE_DELETED
  PROFILE_CREATED_BY_STAFF
  PROFILE_UPDATED_BY_STAFF
  PROFILE_DELETED_BY_STAFF
  PROFILE_ACTIVATED_BY_STAFF
  PROFILE_DEACTIVATED_BY_STAFF
  PRODUCT_CREATED
  PRODUCT_UPDATED
  PRODUCT_DELETED
  PRODUCT_CREATED_BY_STAFF
  PRODUCT_UPDATED_BY_STAFF
  PRODUCT_DELETED_BY_STAFF
  PRODUCT_ACTIVATED_BY_STAFF
  PRODUCT_DEACTIVATED_BY_STAFF
}

input AccountFilterInput {
  dateJoined: DateRangeInput
  lastLogin: DateRangeInput
  status: AccountStatus
  search: String
}

input AccountInput {
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # Billing address of the account.
  defaultBillingAddress: AddressInput
  # Shipping address of the account.
  defaultShippingAddress: AddressInput
}

# Register a new user.
type AccountRegister {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Informs whether users need to confirm their email address.
  requiresConfirmation: Boolean
  accountErrors: [AccountError!]!
  user: User
}

input AccountRegisterInput {
  # The email address of the user.
  email: String!
  # Password.
  password: String!
  # Base of frontend URL that will be needed to create confirmation URL.
  redirectUrl: String
}

# Sends an email with the account removal link for the logged-in user.
type AccountRequestDeletion {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
}

# Sets a default address for the authenticated user.
type AccountSetDefaultAddress {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

enum AccountStatus {
  ACTIVE
  INACTIVE
}

# Updates the account of the logged-in user.
type AccountUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Updates an existing account.
type AccountUpdatebyStaff {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
  user: User
}

# Represents user address data.
type Address implements Node {
  # The ID of the object.
  id: ID!
  addressName: String!
  firstName: String!
  lastName: String!
  companyName: String!
  streetAddress1: String!
  streetAddress2: String!
  city: String!
  cityArea: String!
  postalCode: String!
  # Shop's default country.
  country: CountryDisplay!
  countryArea: String!
  phone: String!
  # Address is user's default shipping address.
  isDefaultShippingAddress: Boolean
  # Address is user's default billing address.
  isDefaultBillingAddress: Boolean
}

# Creates user address.
type AddressCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A user instance for which the address was created.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

# Deletes an address.
type AddressDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A user instance for which the address was deleted.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

input AddressInput {
  # Given name.
  addressName: String
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # Company or organization.
  companyName: String
  # Address.
  streetAddress1: String
  # Address.
  streetAddress2: String
  # City.
  city: String
  # District.
  cityArea: String
  # Postal code.
  postalCode: String
  # Country.
  country: CountryCode
  # State or province.
  countryArea: String
  # Phone number.
  phone: String
}

# Sets a default address for the given user.
type AddressSetDefault {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

# An enumeration.
enum AddressTypeEnum {
  BILLING
  SHIPPING
}

# Updates an address.
type AddressUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A user object for which the address was edited.
  user: User
  accountErrors: [AccountError!]!
  address: Address
}

type AddressValidationData {
  countryCode: String
  countryName: String
  addressFormat: String
  addressLatinFormat: String
  allowedFields: [String]
  requiredFields: [String]
  upperFields: [String]
  countryAreaType: String
  countryAreaChoices: [ChoiceValue]
  cityType: String
  cityChoices: [ChoiceValue]
  cityAreaType: String
  cityAreaChoices: [ChoiceValue]
  postalCodeType: String
  postalCodeMatchers: [String]
  postalCodeExamples: [String]
  postalCodePrefix: String
}

# Represents app data.
type App implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  # Name of the app.
  name: String
  # The date and time when the app was created.
  created: DateTime
  # Determine if app will be set active or not.
  isActive: Boolean
  # List of the app's permissions.
  permissions: [Permission]
  # Last 4 characters of the tokens.
  tokens: [AppToken]
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # Type of the app.
  type: AppTypeEnum
  # List of webhooks assigned to this app.
  webhooks: [Webhook]
  # Description of this app.
  aboutApp: String
  # Description of the data privacy defined for this app.
  dataPrivacy: String
  # Url to details about the privacy policy on the app owner page.
  dataPrivacyUrl: String
  # Homepage of the app.
  homepageUrl: String
  # Support page for the app.
  supportUrl: String
  # Url to iframe with the configuration for the app.
  configurationUrl: String
  # Url to iframe with the app.
  appUrl: String
  # Version number of the app.
  version: String
  # JWT token used to authenticate by thridparty app.
  accessToken: String
}

# Activate the app.
type AppActivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  appErrors: [AppError!]!
  app: App
}

type AppCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [AppCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type AppCountableEdge {
  # The item at the end of the edge.
  node: App!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new app.
type AppCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # The newly created authentication token.
  authToken: String
  appErrors: [AppError!]!
  app: App
}

# Deactivate the app.
type AppDeactivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  appErrors: [AppError!]!
  app: App
}

# Deletes an app.
type AppDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  appErrors: [AppError!]!
  app: App
}

# Delete failed installation.
type AppDeleteFailedInstallation {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  appErrors: [AppError!]!
  appInstallation: AppInstallation
}

type AppError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: AppErrorCode!
  # List of permissions which causes the error.
  permissions: [PermissionEnum!]
}

# An enumeration.
enum AppErrorCode {
  FORBIDDEN
  GRAPHQL_ERROR
  INVALID
  INVALID_STATUS
  INVALID_PERMISSION
  INVALID_URL_FORMAT
  INVALID_MANIFEST_FORMAT
  MANIFEST_URL_CANT_CONNECT
  NOT_FOUND
  REQUIRED
  UNIQUE
  OUT_OF_SCOPE_APP
  OUT_OF_SCOPE_PERMISSION
}

# Fetch and validate manifest.
type AppFetchManifest {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  manifest: Manifest
  appErrors: [AppError!]!
}

input AppFilterInput {
  search: String
  isActive: Boolean
  type: AppTypeEnum
}

input AppInput {
  # Name of the app.
  name: String
  # DEPRECATED: Use the `appActivate` and `appDeactivate` mutations instead.
  isActive: Boolean
  # List of permission code names to assign to this app.
  permissions: [PermissionEnum]
}

# Install new app by using app manifest.
type AppInstall {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  appErrors: [AppError!]!
  appInstallation: AppInstallation
}

# Represents ongoing installation of app.
type AppInstallation implements Node & Job {
  appName: String!
  manifestUrl: String!
  # The ID of the object.
  id: ID!
  # Job status.
  status: JobStatusEnum!
  # Created date time of job in ISO 8601 format.
  createdAt: DateTime!
  # Date time of job last update in ISO 8601 format.
  updatedAt: DateTime!
  # Job message.
  message: String
}

input AppInstallInput {
  # Name of the app to install.
  appName: String
  # Url to app's manifest in JSON format.
  manifestUrl: String
  # Determine if app will be set active or not.
  activateAfterInstallation: Boolean = true
  # List of permission code names to assign to this app.
  permissions: [PermissionEnum]
}

# Retry failed installation of new app.
type AppRetryInstall {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  appErrors: [AppError!]!
  appInstallation: AppInstallation
}

enum AppSortField {
  # Sort apps by name.
  NAME
  # Sort apps by creation date.
  CREATION_DATE
}

input AppSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort apps by the selected field.
  field: AppSortField!
}

# Represents token data.
type AppToken implements Node {
  # Name of the authenticated token.
  name: String
  # Last 4 characters of the token.
  authToken: String
  # The ID of the object.
  id: ID!
}

# Creates a new token.
type AppTokenCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # The newly created authentication token.
  authToken: String
  appErrors: [AppError!]!
  appToken: AppToken
}

# Deletes an authentication token assigned to app.
type AppTokenDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  appErrors: [AppError!]!
  appToken: AppToken
}

input AppTokenInput {
  # Name of the token.
  name: String
  # ID of app.
  app: ID!
}

# Verify provided app token.
type AppTokenVerify {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Determine if token is valid or not.
  valid: Boolean!
  appErrors: [AppError!]!
}

# An enumeration.
enum AppTypeEnum {
  LOCAL
  THIRDPARTY
}

# Updates an existing app.
type AppUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  appErrors: [AppError!]!
  app: App
}

# Assigns storefront's navigation menus.
type AssignNavigation {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Assigned navigation menu.
  menu: Menu
  menuErrors: [MenuError!]!
}

type AuthorizationKey {
  # Name of the authorization backend.
  name: AuthorizationKeyType!
  # Authorization key (client ID).
  key: String!
}

# Adds an authorization key.
type AuthorizationKeyAdd {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Newly added authorization key.
  authorizationKey: AuthorizationKey
  # Updated site.
  site: Site
  siteErrors: [SiteError!]!
}

# Deletes an authorization key.
type AuthorizationKeyDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Authorization key that was deleted.
  authorizationKey: AuthorizationKey
  # Updated site.
  site: Site
  siteErrors: [SiteError!]!
}

input AuthorizationKeyInput {
  # Client authorization key (client ID).
  key: String!
  # Client secret.
  password: String!
}

# An enumeration.
enum AuthorizationKeyType {
  FACEBOOK
  GOOGLE_OAUTH2
}

input BaseAccountInput {
  # Billing address of the account.
  defaultBillingAddress: AddressInput
  # Shipping address of the account.
  defaultShippingAddress: AddressInput
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # The unique email address of the user.
  email: String
  # User account is active.
  isActive: Boolean
  # A note about the user.
  note: String
}

# A static blog that can be manually added by a shop operator through the dashboard.
type Blog implements Node {
  # The ID of the object.
  id: ID!
  seoTitle: String
  seoDescription: String
  title: String!
  summary: String!
  content: String!
  contentJson: JSONString!
  creationDate: DateTime!
  publicationDate: Date
  updateDate: Date!
  isPublished: Boolean!
  slug: String!
  # Returns translated blog fields for the given language code.
  translation(
    # A language code to return the translation for blog.
    languageCode: LanguageCodeEnum!
  ): BlogTranslation
}

# Deletes blogs.
type BlogBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  blogErrors: [BlogError!]!
}

# Publish blogs.
type BlogBulkPublish {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  blogErrors: [BlogError!]!
}

type BlogCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [BlogCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type BlogCountableEdge {
  # The item at the end of the edge.
  node: Blog!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new blog.
type BlogCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  blogErrors: [BlogError!]!
  blog: Blog
}

# Deletes a blog.
type BlogDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  blogErrors: [BlogError!]!
  blog: Blog
}

type BlogError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: BlogErrorCode!
}

# An enumeration.
enum BlogErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

input BlogFilterInput {
  search: String
}

input BlogInput {
  # Blog internal name.
  slug: String
  # Blog title.
  title: String
  # Blog summary.
  summary: String
  # Blog content. May consist of ordinary text, HTML and images.
  content: String
  # Blog content in JSON format.
  contentJson: JSONString
  # Determines if blog is visible in the storefront.
  isPublished: Boolean
  # Publication date. ISO 8601 standard.
  publicationDate: String
  # Search engine optimization fields.
  seo: SeoInput
}

enum BlogSortField {
  # Sort blogs by title.
  TITLE
  # Sort blogs by slug.
  SLUG
  # Sort blogs by visibility.
  VISIBILITY
  # Sort blogs by creation date.
  CREATION_DATE
  # Sort blogs by publication date.
  PUBLICATION_DATE
}

input BlogSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort blogs by the selected field.
  field: BlogSortField!
}

type BlogTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  seoTitle: String
  seoDescription: String
  title: String!
  summary: String!
  content: String!
  contentJson: JSONString!
  # Returns translated blog fields for the given language code.
  translation(
    # A language code to return the translation for blog.
    languageCode: LanguageCodeEnum!
  ): BlogTranslation
  # ('A blog that can be manually added by a site operator ', 'through the dashboard.')
  blog: Blog
}

# Creates/Updates translations for Blog.
type BlogTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  translationErrors: [TranslationError!]!
  blog: BlogTranslatableContent
}

type BlogTranslation implements Node {
  # The ID of the object.
  id: ID!
  seoTitle: String
  seoDescription: String
  title: String!
  summary: String!
  content: String!
  contentJson: JSONString!
  # Translation language.
  language: LanguageDisplay!
}

input BlogTranslationInput {
  seoTitle: String
  seoDescription: String
  title: String
  description: JSONString
  content: String
  contentJson: JSONString
}

# Updates an existing blog.
type BlogUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  blogErrors: [BlogError!]!
  blog: Blog
}

# Company brochures.
type Brochure implements Node {
  # The ID of the object.
  id: ID!
  company: Company
  brochure: String!
  name: String!
  description: String!
  order: Int!
}

type BrochureCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [BrochureCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type BrochureCountableEdge {
  # The item at the end of the edge.
  node: Brochure!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new brochure.
type BrochureCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  brochure: Brochure
  profileErrors: [ProfileError!]!
}

# Deletes a brochure.
type BrochureDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProfileError!]!
  brochure: Brochure
}

input BrochureInput {
  # Company brochure file.
  brochure: Upload
  # The description of company brochure.
  description: String
  # The order of your brochure.
  order: Int
}

# Updates an existing brochure.
type BrochureUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  brochure: Brochure
  profileErrors: [ProfileError!]!
}

# Product categories.
type Category implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  name: String!
  slug: String!
  description: String!
  descriptionJson: JSONString!
  parent: Category
  # List of products under the category.
  products: [Product]
  # List of children of the category.
  children: [Category]
  backgroundImage(
    # Size of the image.
    size: Int
  ): Image
}

type CategoryCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [CategoryCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type CategoryCountableEdge {
  # The item at the end of the edge.
  node: Category!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new category.
type CategoryCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productErrors: [ProductError!]!
  category: Category
}

# Deletes a category.
type CategoryDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productErrors: [ProductError!]!
  category: Category
}

input CategoryInput {
  # Category description (HTML/text).
  description: String
  # Category description (JSON).
  descriptionJson: JSONString
  # Category name.
  name: String
  # Category slug.
  slug: String
  # Search engine optimization fields.
  seo: SeoInput
  # Background image file.
  backgroundImage: Upload
  # Alt text for an image.
  backgroundImageAlt: String
}

# Updates a category.
type CategoryUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productErrors: [ProductError!]!
  category: Category
}

# Company certificates.
type Certificate implements Node {
  # The ID of the object.
  id: ID!
  company: Company
  certificate: String!
  name: String!
  description: String!
  order: Int!
}

type CertificateCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [CertificateCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type CertificateCountableEdge {
  # The item at the end of the edge.
  node: Certificate!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new certificate.
type CertificateCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  certificate: Certificate
  profileErrors: [ProfileError!]!
}

# Deletes a certificate.
type CertificateDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProfileError!]!
  certificate: Certificate
}

input CertificateInput {
  #  Companycertificate file.
  certificate: Upload
  # The description of company certificate.
  description: String
  # The order of your certificate.
  order: Int
}

# Updates an existing certificate.
type CertificateUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  certificate: Certificate
  profileErrors: [ProfileError!]!
}

type ChoiceValue {
  raw: String
  verbose: String
}

# Company profile.
type Company implements Node {
  seoTitle: String
  seoDescription: String
  creationDate: DateTime!
  publicationDate: Date
  updateDate: Date!
  isPublished: Boolean!
  # The ID of the object.
  id: ID!
  user: User
  slug: String!
  name: String!
  logo(
    # Sizes of the company logo.
    size: Int
  ): Image
  logoAlt: String!
  address: Address
  foundedYear: Int!
  # Company number of employees.
  noOfEmployees: String
  email: String!
  content: String!
  contentJson: JSONString!
  isActive: Boolean!
  # Company representative.
  representative: Representative
  # List of company certificates.
  certificates: [Certificate]
  # List of company brochures.
  brochures: [Brochure]
  # List of company videos.
  videos: [Video]
  # List of company social responsibilities.
  socialResponsibilities: [SocialResponsibility]
  # Company product categories.
  categories: [Category]
  # Company products.
  products: [Product]
}

# Activates a company.
type CompanyActivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  company: Company
  profileErrors: [ProfileError!]!
}

# Create an address for the company.
type CompanyAddressCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A company profile for which the address was created.
  company: Company
  accountErrors: [AccountError!]!
  address: Address
}

# Deletes an address of the company.
type CompanyAddressDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
  address: Address
}

# Updates an address of the company.
type CompanyAddressUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
  address: Address
}

# Deletes company profiles.
type CompanyBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  profileErrors: [ProfileError!]!
}

# Updates company profiles.
type CompanyBulkUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  profileErrors: [ProfileError!]!
}

type CompanyCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [CompanyCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type CompanyCountableEdge {
  # The item at the end of the edge.
  node: Company!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new company.
type CompanyCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  company: Company
  profileErrors: [ProfileError!]!
}

# Deactivates a company profile.
type CompanyDeactivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProfileError!]!
  company: Company
}

# Deletes a company profile.
type CompanyDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProfileError!]!
  company: Company
}

input CompanyFilterInput {
  search: String
  status: ProfileStatus
  isActive: ProfileActivationStatus
  isPublished: ProfilePublishedStatus
  dateCreated: DateRangeInput
}

input CompanyInput {
  # Company name.
  name: String
  # Company username slug.
  slug: String
  # Company logo file.
  logo: Upload
  # Alt text for your Company logo.
  logoAlt: String
  # Billing address of the account.
  address: AddressInput
  # Company founded year.
  foundedYear: Int
  # Company number of employees.
  noOfEmployees: String
  # Company contact email address.
  email: String
  # Company content (HTML/text).
  content: String
  # Company content (JSON).
  contentJson: JSONString
  # List of export countries of the company
  exportCountries: [ID]
  # Determines if product is visible to customers.
  isPublished: Boolean
  # Publication date. ISO 8601 standard.
  publicationDate: String
  # Search engine optimization fields.
  seo: SeoInput
}

# Publishes a company.
type CompanyPublish {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A published company.
  profile: Company
  profileErrors: [ProfileError!]!
  company: Company
}

enum CompanySortField {
  # Sort companies by slug.
  SLUG
  # Sort companies by name.
  NAME
  # Sort companies by date created.
  DATE_CREATED
}

input CompanySortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort companies by the selected field.
  field: CompanySortField!
}

# Unpublishes a company.
type CompanyUnpublish {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  company: Company
  profileErrors: [ProfileError!]!
}

# Updates an existing company.
type CompanyUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  company: Company
  profileErrors: [ProfileError!]!
}

# Stores information about a single configuration field.
type ConfigurationItem {
  # Name of the field.
  name: String!
  # Current value of the field.
  value: String
  # Type of the field.
  type: ConfigurationTypeFieldEnum
  # Help text for the field.
  helpText: String
  # Label for the field.
  label: String
}

input ConfigurationItemInput {
  # Name of the field to update.
  name: String!
  # Value of the given field to update.
  value: String
}

# An enumeration.
enum ConfigurationTypeFieldEnum {
  STRING
  BOOLEAN
  SECRET
  PASSWORD
}

# Confirm user account with token sent by email during registration.
type ConfirmAccount {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # An activated user account.
  user: User
  accountErrors: [AccountError!]!
}

# Confirm the email change of the logged-in user.
type ConfirmEmailChange {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A user instance with a new email.
  user: User
  accountErrors: [AccountError!]!
}

# Company contact messages.
type Contact implements Node {
  # The ID of the object.
  id: ID!
  company: Company
  name: String!
  email: String!
  country: String!
  submissionDate: DateTime!
  askForReference: Boolean!
  subject: String!
  content: String!
  type: ContactType
  status: ContactStatus
}

type ContactCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ContactCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ContactCountableEdge {
  # The item at the end of the edge.
  node: Contact!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new contact.
type ContactCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  contact: Contact
  profileErrors: [ProfileError!]!
}

# Deletes a contact.
type ContactDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProfileError!]!
  contact: Contact
}

input ContactInput {
  # Name of the sender.
  name: String
  # The email of the sender.
  email: String
  # The subject of the contact.
  subject: String
  # The content of the contact.
  content: String
  # The type of the contact.
  type: String
}

# An enumeration.
enum ContactStatus {
  # New
  NEW
  # Ongoing
  ONGOING
  # Done
  DONE
  # Spam
  SPAM
}

# An enumeration.
enum ContactType {
  # Info
  INFO
  # Quotation
  QUOTATION
  # Other
  OTHER
}

# Updates a contact.
type ContactUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  contact: Contact
  profileErrors: [ProfileError!]!
}

input ContactUpdateInput {
  # Update the status of your contact.
  status: String
  # Update the type of your contact.
  type: String
}

# An enumeration.
enum CountryCode {
  AF
  AX
  AL
  DZ
  AS
  AD
  AO
  AI
  AQ
  AG
  AR
  AM
  AW
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BQ
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  CV
  KH
  CM
  CA
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  CI
  HR
  CU
  CW
  CY
  CZ
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  SZ
  ET
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GU
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  VA
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MG
  MW
  MY
  MV
  ML
  MT
  MH
  MQ
  MR
  MU
  YT
  MX
  FM
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  KP
  MK
  MP
  NO
  OM
  PK
  PW
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  PR
  QA
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  VC
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  KR
  SS
  ES
  LK
  SD
  SR
  SJ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  UM
  US
  UY
  UZ
  VU
  VE
  VN
  VG
  VI
  WF
  EH
  YE
  ZM
  ZW
}

type CountryDisplay {
  # Country code.
  code: String!
  # Country name.
  country: String!
  # Country tax.
  vat: VAT
}

# Create JWT token.
type CreateToken {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # JWT token, required to authenticate.
  token: String
  # JWT refresh token, required to re-generate access token.
  refreshToken: String
  # CSRF token required to re-generate access token.
  csrfToken: String
  # A user instance.
  user: User
  accountErrors: [AccountError!]!
}

type CreditCard {
  # Card brand.
  brand: String!
  # The host name of the domain.
  firstDigits: String!
  # Last 4 digits of the card number.
  lastDigits: String!
  # Two-digit number representing the card’s expiration month.
  expMonth: Int!
  # Four-digit number representing the card’s expiration year.
  expYear: Int!
}

# The `Date` scalar type represents a Date
# value as specified by
# [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
scalar Date

input DateRangeInput {
  # Start date.
  gte: Date
  # End date.
  lte: Date
}

# The `DateTime` scalar type represents a DateTime
# value as specified by
# [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
scalar DateTime

# Deactivate all JWT tokens of the currently authenticated user.
type DeactivateAllUserTokens {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
}

# Custom Decimal implementation.
#
# Returns Decimal as a float in the API,
# parses float to the Decimal on the way back.
scalar Decimal

# Delete metadata of an object.
type DeleteMetadata {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadata
}

# Delete object's private metadata.
type DeletePrivateMetadata {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadata
}

# Represents site's domain.
type Domain {
  # The host name of the domain.
  host: String!
  # Inform if SSL is enabled.
  sslEnabled: Boolean!
  # Site's absolute URL.
  url: String!
}

# Represents an error in the input of a mutation.
type Error {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
}

# Payment gateway client configuration key and value pair.
type GatewayConfigLine {
  # Gateway config key.
  field: String!
  # Gateway config value for key.
  value: String
}

# The `GenericScalar` scalar type represents a generic
# GraphQL scalar value that could be:
# String, Boolean, Int, Float, List or Object.
scalar GenericScalar

# Represents customers's geolocalization data.
type Geolocalization {
  # Country of the user acquired by his IP address.
  country: CountryDisplay
}

# Represents permission group data.
type Group implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # List of group permissions
  permissions: [Permission]
  # List of group users
  users: [User]
  # True, if the currently authenticated user has rights to manage a group.
  userCanManage: Boolean!
}

type GroupCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [GroupCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type GroupCountableEdge {
  # The item at the end of the edge.
  node: Group!
  # A cursor for use in pagination.
  cursor: String!
}

type HelpdeskError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: HelpdeskErrorCode!
}

# An enumeration.
enum HelpdeskErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
}

# Represents an image.
type Image {
  # The URL of the image.
  url: String!
  # Alt text for an image.
  alt: String
}

# Represents an Invoice.
type Invoice implements ObjectWithMetadata & Job & Node {
  # The ID of the object.
  id: ID!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # Job status.
  status: JobStatusEnum!
  number: String
  externalUrl: String
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # Created date time of job in ISO 8601 format.
  createdAt: DateTime!
  # Date time of job last update in ISO 8601 format.
  updatedAt: DateTime!
  # Job message.
  message: String
  # URL to download an invoice.
  url: String
}

# Creates a ready to send invoice.
type InvoiceCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

input InvoiceCreateInput {
  # Invoice number.
  number: String!
  # URL of an invoice to download.
  url: String!
}

# Deletes an invoice.
type InvoiceDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

type InvoiceError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: InvoiceErrorCode!
}

# An enumeration.
enum InvoiceErrorCode {
  REQUIRED
  NOT_READY
  URL_NOT_SET
  EMAIL_NOT_SET
  NUMBER_NOT_SET
  NOT_FOUND
  INVALID_STATUS
}

# Request an invoice for the order using plugin.
type InvoiceRequest {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Order related to an invoice.
  order: Order
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

# Requests deletion of an invoice.
type InvoiceRequestDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

# Send an invoice by email.
type InvoiceSendEmail {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

# Updates an invoice.
type InvoiceUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  invoiceErrors: [InvoiceError!]!
  invoice: Invoice
}

interface Job {
  # Job status.
  status: JobStatusEnum!
  # Created date time of job in ISO 8601 format.
  createdAt: DateTime!
  # Date time of job last update in ISO 8601 format.
  updatedAt: DateTime!
  # Job message.
  message: String
}

# An enumeration.
enum JobStatusEnum {
  PENDING
  SUCCESS
  FAILED
  DELETED
}

# Allows use of a JSON String for input / output from the GraphQL schema.
#
# Use of this type is *not recommended* as you lose the benefits of having a defined, static
# schema (one of the key benefits of GraphQL).
scalar JSONString

# An enumeration.
enum LanguageCodeEnum {
  EN
  ES
}

type LanguageDisplay {
  # ISO 639 representation of the language name.
  code: LanguageCodeEnum!
  # Full name of the language.
  language: String!
}

# The manifest definition.
type Manifest {
  identifier: String!
  version: String!
  name: String!
  about: String
  permissions: [Permission]
  appUrl: String
  configurationUrl: String
  tokenTargetUrl: String
  dataPrivacy: String
  dataPrivacyUrl: String
  homepageUrl: String
  supportUrl: String
}

# Represents a single menu - an object that is used to help navigate through the store.
type Menu implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  items: [MenuItem]
}

# Deletes menus.
type MenuBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  menuErrors: [MenuError!]!
}

type MenuCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [MenuCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type MenuCountableEdge {
  # The item at the end of the edge.
  node: Menu!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new Menu.
type MenuCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  menuErrors: [MenuError!]!
  menu: Menu
}

input MenuCreateInput {
  # Name of the menu.
  name: String!
  # List of menu items.
  items: [MenuItemInput]
}

# Deletes a menu.
type MenuDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  menuErrors: [MenuError!]!
  menu: Menu
}

type MenuError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: MenuErrorCode!
}

# An enumeration.
enum MenuErrorCode {
  CANNOT_ASSIGN_NODE
  GRAPHQL_ERROR
  INVALID
  INVALID_MENU_ITEM
  NO_MENU_ITEM_PROVIDED
  NOT_FOUND
  REQUIRED
  TOO_MANY_MENU_ITEMS
  UNIQUE
}

input MenuFilterInput {
  search: String
}

input MenuInput {
  # Name of the menu.
  name: String
}

# Represents a single item of the related menu. Can store pages, blogs, etc.
type MenuItem implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  menu: Menu!
  parent: MenuItem
  page: Page
  level: Int!
  children: [MenuItem]
  # URL to the menu item.
  url: String
  # Returns translated menu item fields for the given language code.
  translation(
    # A language code to return the translation for menu item.
    languageCode: LanguageCodeEnum!
  ): MenuItemTranslation
}

# Deletes menu items.
type MenuItemBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  menuErrors: [MenuError!]!
}

type MenuItemCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [MenuItemCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type MenuItemCountableEdge {
  # The item at the end of the edge.
  node: MenuItem!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new menu item.
type MenuItemCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  menuErrors: [MenuError!]!
  menuItem: MenuItem
}

input MenuItemCreateInput {
  # Name of the menu item.
  name: String!
  # URL of the pointed item.
  url: String
  # Page to which item points.
  page: ID
  # Menu to which item belongs.
  menu: ID!
  # ID of the parent menu. If empty, menu will be top level menu.
  parent: ID
}

# Deletes a menu item.
type MenuItemDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  menuErrors: [MenuError!]!
  menuItem: MenuItem
}

input MenuItemFilterInput {
  search: String
}

input MenuItemInput {
  # Name of the menu item.
  name: String
  # URL of the pointed item.
  url: String
  # Page to which item points.
  page: ID
}

# Moves items of menus.
type MenuItemMove {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Assigned menu to move within.
  menu: Menu
  menuErrors: [MenuError!]!
}

input MenuItemMoveInput {
  # The menu item ID to move.
  itemId: ID!
  # ID of the parent menu. If empty, menu will be top level menu.
  parentId: ID
  # Sorting position of the menu item (from 0 to x).
  sortOrder: Int
}

input MenuItemSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort menu items by the selected field.
  field: MenuItemsSortField!
}

enum MenuItemsSortField {
  # Sort menu items by name.
  NAME
}

type MenuItemTranslatableContent implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Returns translated menu item fields for the given language code.
  translation(
    # A language code to return the translation for menu item.
    languageCode: LanguageCodeEnum!
  ): MenuItemTranslation
  # Represents a single item of the related menu. Can store categories, collection or pages.
  menuItem: MenuItem
}

# Creates/Updates translations for Menu Item.
type MenuItemTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  translationErrors: [TranslationError!]!
  menuItem: MenuItem
}

type MenuItemTranslation implements Node {
  # The ID of the object.
  id: ID!
  name: String!
  # Translation language.
  language: LanguageDisplay!
}

# Updates a menu item.
type MenuItemUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  menuErrors: [MenuError!]!
  menuItem: MenuItem
}

enum MenuSortField {
  # Sort menus by name.
  NAME
  # Sort menus by items count.
  ITEMS_COUNT
}

input MenuSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort menus by the selected field.
  field: MenuSortField!
}

# Updates a menu.
type MenuUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  menuErrors: [MenuError!]!
  menu: Menu
}

type MetadataError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: MetadataErrorCode!
}

# An enumeration.
enum MetadataErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
}

input MetadataInput {
  # Key of a metadata item.
  key: String!
  # Value of a metadata item.
  value: String!
}

type MetadataItem {
  # Key of a metadata item.
  key: String!
  # Value of a metadata item.
  value: String!
}

# Represents amount of money in specific currency.
type Money {
  # Currency code.
  currency: String!
  # Amount of money.
  amount: Float!
}

type Mutation {
  # Creates a new webhook subscription.
  webhookCreate(
    # Fields required to create a webhook.
    input: WebhookCreateInput!
  ): WebhookCreate
  # Deletes a webhook subscription.
  webhookDelete(
    # ID of a webhook to delete.
    id: ID!
  ): WebhookDelete
  # Updates a webhook subscription.
  webhookUpdate(
    # ID of a webhook to update.
    id: ID!
    # Fields required to update a webhook.
    input: WebhookUpdateInput!
  ): WebhookUpdate
  # Adds an authorization key.
  authorizationKeyAdd(
    # Fields required to create an authorization key.
    input: AuthorizationKeyInput!
    # Type of an authorization key to add.
    keyType: AuthorizationKeyType!
  ): AuthorizationKeyAdd
  # Deletes an authorization key.
  authorizationKeyDelete(
    # Type of a key to delete.
    keyType: AuthorizationKeyType!
  ): AuthorizationKeyDelete
  # Creates a new staff notification recipient.
  staffNotificationRecipientCreate(
    # Fields required to create a staff notification recipient.
    input: StaffNotificationRecipientInput!
  ): StaffNotificationRecipientCreate
  # Updates a staff notification recipient.
  staffNotificationRecipientUpdate(
    # ID of a staff notification recipient to update.
    id: ID!
    # Fields required to update a staff notification recipient.
    input: StaffNotificationRecipientInput!
  ): StaffNotificationRecipientUpdate
  # Delete staff notification recipient.
  staffNotificationRecipientDelete(
    # ID of a staff notification recipient to delete.
    id: ID!
  ): StaffNotificationRecipientDelete
  # Updates site domain of the site.
  siteDomainUpdate(
    # Fields required to update site.
    input: SiteDomainInput
  ): SiteDomainUpdate
  # Updates site settings.
  siteSettingsUpdate(
    # Fields required to update site settings.
    input: SiteSettingsInput!
  ): SiteSettingsUpdate
  # Fetch tax rates.
  siteFetchTaxRates: SiteFetchTaxRates
  # Creates/Updates translations for Site Settings.
  siteSettingsTranslate(
    # Fields required to update site settings translations.
    input: SiteSettingsTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): SiteSettingsTranslate
  # Update the site's address. If the `null` value is passed, the currently selected address will be deleted.
  siteAddressUpdate(
    # Fields required to update site address.
    input: AddressInput
  ): SiteAddressUpdate
  # Creates a new company.
  companyCreate(
    # Fields required to create a company.
    input: CompanyInput!
  ): CompanyCreate
  # Activates a company.
  companyActivate(
    # ID of a company to activate.
    id: ID!
  ): CompanyActivate
  # Publishes a company.
  companyPublish(
    # ID of a company to be published.
    id: ID!
  ): CompanyPublish
  # Updates an existing company.
  companyUpdate(
    # ID of a company to update.
    id: ID!
    # Fields required to update a company.
    input: CompanyInput!
  ): CompanyUpdate
  # Unpublishes a company.
  companyUnpublish(
    # ID of a company to be unpublished.
    id: ID!
  ): CompanyUnpublish
  # Deactivates a company profile.
  companyDeactivate(
    # ID of a company to deactivate.
    id: ID!
  ): CompanyDeactivate
  # Deletes a company profile.
  companyDelete(
    # ID of a company to delete.
    id: ID!
  ): CompanyDelete
  # Create an address for the company.
  companyAddressCreate(
    # ID of a company to create address for.
    companyId: ID!
    # Fields required to create address.
    input: AddressInput!
  ): CompanyAddressCreate
  # Updates an address of the company.
  companyAddressUpdate(
    # ID of the address to be updated.
    id: ID!
    # Fields required to create address.
    input: AddressInput!
  ): CompanyAddressUpdate
  # Deletes an address of the company.
  companyAddressDelete(
    # ID of the company address to be deleted.
    id: ID!
  ): CompanyAddressDelete
  # Creates a new representative.
  representativeCreate(
    # ID of a company to add representative.
    companyId: ID!
    # Fields required to create a representative.
    input: RepresentativeInput!
  ): RepresentativeCreate
  # Updates an existing ticket.
  representativeUpdate(
    # ID of a representative to update.
    id: ID!
    # Fields required to update a representative.
    input: RepresentativeInput!
  ): RepresentativeUpdate
  # Deletes a representative.
  representativeDelete(
    # ID of a representative to delete.
    id: ID!
  ): RepresentativeDelete
  # Creates a new certificate.
  certificateCreate(
    # ID of a company to add certificate.
    companyId: ID!
    # Fields required to create a certificate.
    input: CertificateInput!
  ): CertificateCreate
  # Updates an existing certificate.
  certificateUpdate(
    # ID of a certificate to update.
    id: ID!
    # Fields required to update a certificate.
    input: CertificateInput!
  ): CertificateUpdate
  # Deletes a certificate.
  certificateDelete(
    # ID of a certificate to delete.
    id: ID!
  ): CertificateDelete
  # Creates a new brochure.
  brochureCreate(
    # ID of a company to add brochure.
    companyId: ID!
    # Fields required to create a brochure.
    input: BrochureInput!
  ): BrochureCreate
  # Updates an existing brochure.
  brochureUpdate(
    # ID of a brochure to update.
    id: ID!
    # Fields required to update a brochure.
    input: BrochureInput!
  ): BrochureUpdate
  # Deletes a brochure.
  brochureDelete(
    # ID of a brochure to delete.
    id: ID!
  ): BrochureDelete
  # Creates a new video.
  videoCreate(
    # ID of a company to add video.
    companyId: ID!
    # Fields required to create a video.
    input: VideoInput!
  ): VideoCreate
  # Updates an existing ticket.
  videoUpdate(
    # ID of a video to update.
    id: ID!
    # Fields required to update a video.
    input: VideoInput!
  ): VideoUpdate
  # Deletes a video.
  videoDelete(
    # ID of a video to delete.
    id: ID!
  ): VideoDelete
  # Creates a new social responsibility.
  socialResponsibilityCreate(
    # ID of a company to add social responsibility.
    companyId: ID!
    # Fields required to create a social responsibility.
    input: SocialResponsibilityInput!
  ): SocialResponsibilityCreate
  # Updates an existing social responsibility.
  socialResponsibilityUpdate(
    # ID of a social responsibility to update.
    id: ID!
    # Fields required to update a social responsibility.
    input: SocialResponsibilityInput!
  ): SocialResponsibilityUpdate
  # Deletes a social responsibility.
  socialResponsibilityDelete(
    # ID of a social responsibility to delete.
    id: ID!
  ): SocialResponsibilityDelete
  # Creates a new contact.
  contactCreate(
    # ID of a company to add contact.
    companyId: ID!
    # Fields required to create a contact.
    input: ContactInput!
  ): ContactCreate
  # Updates a contact.
  contactUpdate(
    # ID of a contact to delete.
    id: ID!
    # Fields to update in your contact message.
    input: ContactUpdateInput!
  ): ContactUpdate
  # Deletes a contact.
  contactDelete(
    # ID of a contact to delete.
    id: ID!
  ): ContactDelete
  # Updates company profiles.
  companyBulkUpdate(
    # List of company profiles to update.
    ids: [ID]!
    # Update the status of company profiles.
    isActive: Boolean!
  ): CompanyBulkUpdate
  # Deletes company profiles.
  companyBulkDelete(
    # List of company profiles to delete.
    ids: [ID]!
  ): CompanyBulkDelete
  # Creates a new category.
  categoryCreate(
    # Fields required to create a category.
    input: CategoryInput!
    # ID of the parent category. If empty, category will be top level category.
    parent: ID
  ): CategoryCreate
  # Updates a category.
  categoryUpdate(
    # ID of a category to update.
    id: ID!
    # Fields required to update a category.
    input: CategoryInput!
  ): CategoryUpdate
  # Deletes a category.
  categoryDelete(
    # ID of a category to delete.
    id: ID!
  ): CategoryDelete
  # Creates a new product.
  productCreate(
    # Fields required to create a product.
    input: ProductInput!
  ): ProductCreate
  # Activates a product.
  productActivate(
    # ID of a product to activate.
    productId: ID!
  ): ProductActivate
  # Publishes a product.
  productPublish(
    # ID of a product to be published.
    productId: ID!
  ): ProductPublish
  # Updates an existing product.
  productUpdate(
    # Fields required to update a product.
    input: ProductInput!
    # ID of a product to update.
    productId: ID!
  ): ProductUpdate
  # Unpublishes a product.
  productUnpublish(
    # ID of a product to be unpublished.
    productId: ID!
  ): ProductUnpublish
  # Deactivates a product.
  productDeactivate(
    # ID of a product to deactivate.
    productId: ID!
  ): ProductDeactivate
  # Deletes a product.
  productDelete(
    # ID of a product to delete.
    productId: ID!
  ): ProductDelete
  # Creates a new product price.
  productPriceCreate(
    # Fields required to create a product price.
    input: ProductPriceInput!
    # ID of a product to add product price.
    productId: ID!
  ): ProductPriceCreate
  # Updates an existing product price.
  productPriceUpdate(
    # Fields required to update a product price.
    input: ProductPriceInput!
    # ID of a product price to update.
    productPriceId: ID!
  ): ProductPriceUpdate
  # Deletes a product price.
  productPriceDelete(
    # ID of a product price to delete.
    productPriceId: ID!
  ): ProductPriceDelete
  # Creates a new product image.
  productImageCreate(
    # Fields required to create a product image.
    input: ProductImageInput!
    # ID of a product to add product image.
    productId: ID!
  ): ProductImageCreate
  # Updates an existing product image.
  productImageUpdate(
    # Fields required to update a product image.
    input: ProductImageInput!
    # ID of a product image to update.
    productImageId: ID!
  ): ProductImageUpdate
  # Deletes a product image.
  productImageDelete(
    # ID of a product image to delete.
    productImageId: ID!
  ): ProductImageDelete
  # Creates a new product video.
  productVideoCreate(
    # Fields required to create a product video.
    input: ProductVideoInput!
    # ID of a product to add product video.
    productId: ID!
  ): ProductVideoCreate
  # Updates an existing product video.
  productVideoUpdate(
    # Fields required to update a product video.
    input: ProductVideoInput!
    # ID of a product video to update.
    productVideoId: ID!
  ): ProductVideoUpdate
  # Deletes a product video.
  productVideoDelete(
    # ID of a product video to delete.
    productVideoId: ID!
  ): ProductVideoDelete
  # Updates company products.
  productBulkUpdate(
    # List of company products to update.
    ids: [ID]!
    # Update the status of company products.
    isActive: Boolean!
  ): ProductBulkUpdate
  # Deletes company products.
  productBulkDelete(
    # List of company products to delete.
    ids: [ID]!
  ): ProductBulkDelete
  # Captures the authorized payment amount.
  paymentCapture(
    # Transaction amount.
    amount: Decimal
    # Payment ID.
    paymentId: ID!
  ): PaymentCapture
  # Refunds the captured payment amount.
  paymentRefund(
    # Transaction amount.
    amount: Decimal
    # Payment ID.
    paymentId: ID!
  ): PaymentRefund
  # Voids the authorized payment.
  paymentVoid(
    # Payment ID.
    paymentId: ID!
  ): PaymentVoid
  # Confirms payment in a two-step process like 3D secure
  paymentSecureConfirm(
    # Payment ID.
    paymentId: ID!
  ): PaymentSecureConfirm
  # Creates a new page.
  pageCreate(
    # Fields required to create a page.
    input: PageInput!
  ): PageCreate
  # Deletes a page.
  pageDelete(
    # ID of a page to delete.
    id: ID!
  ): PageDelete
  # Deletes pages.
  pageBulkDelete(
    # List of page IDs to delete.
    ids: [ID]!
  ): PageBulkDelete
  # Publish pages.
  pageBulkPublish(
    # List of page IDs to (un)publish.
    ids: [ID]!
    # Determine if pages will be published or not.
    isPublished: Boolean!
  ): PageBulkPublish
  # Updates an existing page.
  pageUpdate(
    # ID of a page to update.
    id: ID!
    # Fields required to update a page.
    input: PageInput!
  ): PageUpdate
  # Creates/Updates translations for Page.
  pageTranslate(
    # Page ID.
    id: ID!
    input: PageTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): PageTranslate
  # Adds note to the order.
  orderAddNote(
    # ID of the order to add a note for.
    order: ID!
    # Fields required to create a note for the order.
    input: OrderAddNoteInput!
  ): OrderAddNote
  # Cancel an order.
  orderCancel(
    # ID of the order to cancel.
    id: ID!
  ): OrderCancel
  # Capture an order.
  orderCapture(
    # Amount of money to capture.
    amount: Decimal!
    # ID of the order to capture.
    id: ID!
  ): OrderCapture
  # Mark order as manually paid.
  orderMarkAsPaid(
    # ID of the order to mark paid.
    id: ID!
  ): OrderMarkAsPaid
  # Refund an order.
  orderRefund(
    # Amount of money to refund.
    amount: Decimal!
    # ID of the order to refund.
    id: ID!
  ): OrderRefund
  # Updates an order.
  orderUpdate(
    # ID of an order to update.
    id: ID!
    # Fields required to update an order.
    input: OrderUpdateInput!
  ): OrderUpdate
  # Void an order.
  orderVoid(
    # ID of the order to void.
    id: ID!
  ): OrderVoid
  # Cancels orders.
  orderBulkCancel(
    # List of orders IDs to cancel.
    ids: [ID]!
  ): OrderBulkCancel
  # Delete metadata of an object.
  deleteMetadata(
    # ID of an object to update.
    id: ID!
    # Metadata keys to delete.
    keys: [String!]!
  ): DeleteMetadata
  # Delete object's private metadata.
  deletePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Metadata keys to delete.
    keys: [String!]!
  ): DeletePrivateMetadata
  # Updates metadata of an object.
  updateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update the object's metadata.
    input: [MetadataInput!]!
  ): UpdateMetadata
  # Updates private metadata of an object.
  updatePrivateMetadata(
    # ID of an object to update.
    id: ID!
    # Fields required to update the object's metadata.
    input: [MetadataInput!]!
  ): UpdatePrivateMetadata
  # Assigns storefront's navigation menus.
  assignNavigation(
    # ID of the menu.
    menu: ID
    # Type of the navigation bar to assign the menu to.
    navigationType: NavigationType!
  ): AssignNavigation
  # Creates a new Menu.
  menuCreate(
    # Fields required to create a menu.
    input: MenuCreateInput!
  ): MenuCreate
  # Deletes a menu.
  menuDelete(
    # ID of a menu to delete.
    id: ID!
  ): MenuDelete
  # Deletes menus.
  menuBulkDelete(
    # List of menu IDs to delete.
    ids: [ID]!
  ): MenuBulkDelete
  # Updates a menu.
  menuUpdate(
    # ID of a menu to update.
    id: ID!
    # Fields required to update a menu.
    input: MenuInput!
  ): MenuUpdate
  # Creates a new menu item.
  menuItemCreate(
    # Fields required to update a menu item. Only one of `url`, `page` is allowed per item.
    input: MenuItemCreateInput!
  ): MenuItemCreate
  # Deletes a menu item.
  menuItemDelete(
    # ID of a menu item to delete.
    id: ID!
  ): MenuItemDelete
  # Deletes menu items.
  menuItemBulkDelete(
    # List of menu item IDs to delete.
    ids: [ID]!
  ): MenuItemBulkDelete
  # Updates a menu item.
  menuItemUpdate(
    # ID of a menu item to update.
    id: ID!
    # Fields required to update a menu item. Only one of `url`, `page` is allowed per item.
    input: MenuItemInput!
  ): MenuItemUpdate
  # Creates/Updates translations for Menu Item.
  menuItemTranslate(
    # Menu Item ID.
    id: ID!
    input: NameTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): MenuItemTranslate
  # Moves items of menus.
  menuItemMove(
    # ID of the menu.
    menu: ID!
    # The menu position data.
    moves: [MenuItemMoveInput]!
  ): MenuItemMove
  # Request an invoice for the order using plugin.
  invoiceRequest(
    # Invoice number, if not provided it will be generated.
    number: String
    # ID of the order related to invoice.
    orderId: ID!
  ): InvoiceRequest
  # Requests deletion of an invoice.
  invoiceRequestDelete(
    # ID of an invoice to request the deletion.
    id: ID!
  ): InvoiceRequestDelete
  # Creates a ready to send invoice.
  invoiceCreate(
    # Fields required when creating an invoice.
    input: InvoiceCreateInput!
    # ID of the order related to invoice.
    orderId: ID!
  ): InvoiceCreate
  # Deletes an invoice.
  invoiceDelete(
    # ID of an invoice to delete.
    id: ID!
  ): InvoiceDelete
  # Updates an invoice.
  invoiceUpdate(
    # ID of an invoice to update.
    id: ID!
    # Fields to use when updating an invoice.
    input: UpdateInvoiceInput!
  ): InvoiceUpdate
  # Send an invoice by email.
  invoiceSendEmail(
    # ID of an invoice to be sent.
    id: ID!
  ): InvoiceSendEmail
  # Creates a new ticket.
  ticketCreate(
    # Fields required to create a ticket.
    input: TicketInput!
  ): TicketCreate
  # Updates an existing ticket.
  ticketUpdate(
    # Fields required to update a ticket.
    input: TicketInput!
    # ID of a ticket to update.
    ticketId: ID!
  ): TicketUpdate
  # Deletes a ticket.
  ticketDelete(
    # ID of a ticket to delete.
    ticketId: ID!
  ): TicketDelete
  # Deletes tickets.
  ticketBulkDelete(
    # List of ticket IDs to delete.
    ids: [ID]!
  ): TicketBulkDelete
  # Updates tickets.
  ticketBulkUpdate(
    # List of ticket IDs to delete.
    ids: [ID]!
    # Update the status of tickets.
    status: String!
  ): TicketBulkUpdate
  # Update plugin configuration.
  pluginUpdate(
    # ID of plugin to update.
    id: ID!
    # Fields required to update a plugin configuration.
    input: PluginUpdateInput!
  ): PluginUpdate
  # Creates a new blog.
  blogCreate(
    # Fields required to create a blog.
    input: BlogInput!
  ): BlogCreate
  # Deletes a blog.
  blogDelete(
    # ID of a blog to delete.
    id: ID!
  ): BlogDelete
  # Deletes blogs.
  blogBulkDelete(
    # List of blog IDs to delete.
    ids: [ID]!
  ): BlogBulkDelete
  # Publish blogs.
  blogBulkPublish(
    # List of blog IDs to (un)publish.
    ids: [ID]!
    # Determine if blogs will be published or not.
    isPublished: Boolean!
  ): BlogBulkPublish
  # Updates an existing blog.
  blogUpdate(
    # ID of a blog to update.
    id: ID!
    # Fields required to update a blog.
    input: BlogInput!
  ): BlogUpdate
  # Creates/Updates translations for Blog.
  blogTranslate(
    # Blog ID.
    id: ID!
    input: BlogTranslationInput!
    # Translation language code.
    languageCode: LanguageCodeEnum!
  ): BlogTranslate
  # Creates a new app.
  appCreate(
    # Fields required to create a new app.
    input: AppInput!
  ): AppCreate
  # Updates an existing app.
  appUpdate(
    # ID of an app to update.
    id: ID!
    # Fields required to update an existing app.
    input: AppInput!
  ): AppUpdate
  # Deletes an app.
  appDelete(
    # ID of an app to delete.
    id: ID!
  ): AppDelete
  # Creates a new token.
  appTokenCreate(
    # Fields required to create a new auth token.
    input: AppTokenInput!
  ): AppTokenCreate
  # Deletes an authentication token assigned to app.
  appTokenDelete(
    # ID of an auth token to delete.
    id: ID!
  ): AppTokenDelete
  # Verify provided app token.
  appTokenVerify(
    # App token to verify.
    token: String!
  ): AppTokenVerify
  # Install new app by using app manifest.
  appInstall(
    # Fields required to install a new app.
    input: AppInstallInput!
  ): AppInstall
  # Retry failed installation of new app.
  appRetryInstall(
    # Determine if app will be set active or not.
    activateAfterInstallation: Boolean = true
    # ID of failed installation.
    id: ID!
  ): AppRetryInstall
  # Delete failed installation.
  appDeleteFailedInstallation(
    # ID of failed installation to delete.
    id: ID!
  ): AppDeleteFailedInstallation
  # Fetch and validate manifest.
  appFetchManifest(manifestUrl: String!): AppFetchManifest
  # Activate the app.
  appActivate(
    # ID of app to activate.
    id: ID!
  ): AppActivate
  # Deactivate the app.
  appDeactivate(
    # ID of app to deactivate.
    id: ID!
  ): AppDeactivate
  # Create JWT token.
  tokenCreate(
    # Email of a user.
    email: String!
    # Password of a user.
    password: String!
  ): CreateToken
  # Refresh JWT token. Mutation tries to take refreshToken from the input.If it
  # fails it will try to take refreshToken from the http-only cookie
  # -refreshToken. csrfToken is required when refreshToken is provided as a cookie.
  tokenRefresh(
    # CSRF token required to refresh token. This argument is required when refreshToken is provided as a cookie.
    csrfToken: String
    # Refresh token.
    refreshToken: String
  ): RefreshToken
  # Verify JWT token.
  tokenVerify(
    # JWT token to validate.
    token: String!
  ): VerifyToken
  # Deactivate all JWT tokens of the currently authenticated user.
  tokensDeactivateAll: DeactivateAllUserTokens
  # Sends an email with the account password modification link.
  requestPasswordReset(
    # Email of the user that will be used for password recovery.
    email: String!
    # URL of a view where users should be redirected to reset the password. URL in RFC 1808 format.
    redirectUrl: String!
  ): RequestPasswordReset
  # Confirm user account with token sent by email during registration.
  confirmAccount(
    # E-mail of the user performing account confirmation.
    email: String!
    # A one-time token required to confirm the account.
    token: String!
  ): ConfirmAccount
  # Sets the user's password from the token sent by email using the RequestPasswordReset mutation.
  setPassword(
    # Email of a user.
    email: String!
    # Password of a user.
    password: String!
    # A one-time token required to set the password.
    token: String!
  ): SetPassword
  # Change the password of the logged in user.
  passwordChange(
    # New user password.
    newPassword: String!
    # Current user password.
    oldPassword: String!
  ): PasswordChange
  # Request email change of the logged in user.
  requestEmailChange(
    # New user email.
    newEmail: String!
    # User password.
    password: String!
    # URL of a view where users should be redirected to update the email address. URL in RFC 1808 format.
    redirectUrl: String!
  ): RequestEmailChange
  # Confirm the email change of the logged-in user.
  confirmEmailChange(
    # A one-time token required to change the email.
    token: String!
  ): ConfirmEmailChange
  # Create a new address for the account.
  accountAddressCreate(
    # Fields required to create address.
    input: AddressInput!
    # A type of address. If provided, the new address will be automatically
    # assigned as the account's default address of that type.
    type: AddressTypeEnum
  ): AccountAddressCreate
  # Updates an address of the logged-in user.
  accountAddressUpdate(
    # ID of the address to update.
    id: ID!
    # Fields required to update the address.
    input: AddressInput!
  ): AccountAddressUpdate
  # Delete an address of the logged-in user.
  accountAddressDelete(
    # ID of the address to delete.
    id: ID!
  ): AccountAddressDelete
  # Sets a default address for the authenticated user.
  accountSetDefaultAddress(
    # ID of the address to set as default.
    id: ID!
    # The type of address.
    type: AddressTypeEnum!
  ): AccountSetDefaultAddress
  # Register a new user.
  accountRegister(
    # Fields required to create a user.
    input: AccountRegisterInput!
  ): AccountRegister
  # Updates the account of the logged-in user.
  accountUpdate(
    # Fields required to update the account of the logged-in user.
    input: AccountInput!
  ): AccountUpdate
  # Sends an email with the account removal link for the logged-in user.
  accountRequestDeletion(
    # URL of a view where users should be redirected to delete their account. URL in RFC 1808 format.
    redirectUrl: String!
  ): AccountRequestDeletion
  # Deletes an account.
  accountDelete(
    # ID of an account to delete.
    id: ID!
  ): AccountDelete
  # Remove user account by the request.
  accountDeleteByRequest(
    # A one-time token required to remove account. Sent by email using AccountRequestDeletion mutation.
    token: String!
  ): AccountDeletebyRequest
  # Creates user address.
  addressCreate(
    # Fields required to create address.
    input: AddressInput!
    # ID of a user to create address for.
    userId: ID!
  ): AddressCreate
  # Updates an address.
  addressUpdate(
    # ID of the address to update.
    id: ID!
    # Fields required to update the address.
    input: AddressInput!
  ): AddressUpdate
  # Deletes an address.
  addressDelete(
    # ID of the address to delete.
    id: ID!
  ): AddressDelete
  # Sets a default address for the given user.
  addressSetDefault(
    # ID of the address.
    addressId: ID!
    # The type of address.
    type: AddressTypeEnum!
    # ID of the user to change the address for.
    userId: ID!
  ): AddressSetDefault
  # Creates a new account.
  accountCreateByStaff(
    # Fields required to create a account.
    input: UserCreateInput!
  ): AccountCreatebyStaff
  # Updates an existing account.
  accountUpdateByStaff(
    # ID of an account to update.
    id: ID!
    # Fields required to update an account.
    input: BaseAccountInput!
  ): AccountUpdatebyStaff
  # Deletes an account.
  accountDeleteByStaff(
    # ID of an account to delete.
    id: ID!
  ): AccountDeletebyStaff
  # Deletes accounts.
  accountBulkDelete(
    # List of user IDs to delete.
    ids: [ID]!
  ): AccountBulkDelete
  # Creates a new staff user.
  staffCreate(
    # Fields required to create a staff user.
    input: StaffCreateInput!
  ): StaffCreate
  # Updates an existing staff user.
  staffUpdate(
    # ID of a staff user to update.
    id: ID!
    # Fields required to update a staff user.
    input: StaffUpdateInput!
  ): StaffUpdate
  # Deletes a staff user.
  staffDelete(
    # ID of a staff user to delete.
    id: ID!
  ): StaffDelete
  # Deletes staff users.
  staffBulkDelete(
    # List of user IDs to delete.
    ids: [ID]!
  ): StaffBulkDelete
  # Create a user avatar. Only for staff members. This mutation must be sent as a
  # `multipart` request. More detailed specs of the upload format can be found
  # here: https://github.com/jaydenseric/graphql-multipart-request-spec
  userAvatarUpdate(
    # Represents an image file in a multipart request.
    image: Upload!
  ): UserAvatarUpdate
  # Deletes a user avatar. Only for staff members.
  userAvatarDelete: UserAvatarDelete
  # Activate or deactivate users.
  userBulkSetActive(
    # List of user IDs to (de)activate).
    ids: [ID]!
    # Determine if users will be set active or not.
    isActive: Boolean!
  ): UserBulkSetActive
  # Create new permission group.
  permissionGroupCreate(
    # Input fields to create permission group.
    input: PermissionGroupCreateInput!
  ): PermissionGroupCreate
  # Update permission group.
  permissionGroupUpdate(
    # ID of the group to update.
    id: ID!
    # Input fields to create permission group.
    input: PermissionGroupUpdateInput!
  ): PermissionGroupUpdate
  # Delete permission group.
  permissionGroupDelete(
    # ID of the group to delete.
    id: ID!
  ): PermissionGroupDelete
}

input NameTranslationInput {
  name: String
}

# Represents site's navigation menus.
type Navigation {
  # Main navigation bar.
  main: Menu
  # Secondary navigation bar.
  secondary: Menu
}

enum NavigationType {
  # Main site navigation.
  MAIN
  # Secondary site navigation.
  SECONDARY
}

# An object with an ID
interface Node {
  # The ID of the object.
  id: ID!
}

interface ObjectWithMetadata {
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
}

# Represents an order in the shop.
type Order implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  created: DateTime!
  status: OrderStatus!
  user: User
  languageCode: String!
  billingAddress: Address
  token: String!
  note: String!
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of actions that can be performed in the current state of an order.
  actions: [OrderAction]!
  # List of order invoices.
  invoices: [Invoice]
  # User-friendly number of an order.
  number: String
  # Informs if an order is fully paid.
  isPaid: Boolean
  # Internal payment status.
  paymentStatus: PaymentChargeStatusEnum
  # User-friendly payment status.
  paymentStatusDisplay: String
  # List of payments for the order.
  payments: [Payment]
  # Total amount of the order.
  total: TaxedMoney
  # User-friendly order status.
  statusDisplay: String
  # Amount authorized for the order.
  totalAuthorized: Money
  # Amount captured by payment.
  totalCaptured: Money
  # List of events associated with the order.
  events: [OrderEvent]
  # The difference between the paid and the order total amount.
  totalBalance: Money!
  # Email address of the customer.
  userEmail: String
}

enum OrderAction {
  # Represents the capture action.
  CAPTURE
  # Represents a mark-as-paid action.
  MARK_AS_PAID
  # Represents a refund action.
  REFUND
  # Represents a void action.
  VOID
}

# Adds note to the order.
type OrderAddNote {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Order with the note added.
  order: Order
  # Order note created.
  event: OrderEvent
  orderErrors: [OrderError!]!
}

input OrderAddNoteInput {
  # Note message.
  message: String!
}

# Cancels orders.
type OrderBulkCancel {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  orderErrors: [OrderError!]!
}

# Cancel an order.
type OrderCancel {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Canceled order.
  order: Order
  orderErrors: [OrderError!]!
}

# Capture an order.
type OrderCapture {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Captured order.
  order: Order
  orderErrors: [OrderError!]!
}

type OrderCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [OrderCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type OrderCountableEdge {
  # The item at the end of the edge.
  node: Order!
  # A cursor for use in pagination.
  cursor: String!
}

enum OrderDirection {
  # Specifies an ascending sort order.
  ASC
  # Specifies a descending sort order.
  DESC
}

type OrderError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: OrderErrorCode!
  # Warehouse ID which causes the error.
  warehouse: ID
  # Order line ID which causes the error.
  orderLine: ID
}

# An enumeration.
enum OrderErrorCode {
  BILLING_ADDRESS_NOT_SET
  CANNOT_CANCEL_FULFILLMENT
  CANNOT_CANCEL_ORDER
  CANNOT_DELETE
  CANNOT_REFUND
  CAPTURE_INACTIVE_PAYMENT
  NOT_EDITABLE
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  PAYMENT_ERROR
  PAYMENT_MISSING
  REQUIRED
  UNIQUE
  VOID_INACTIVE_PAYMENT
}

# History log of the order.
type OrderEvent implements Node {
  # The ID of the object.
  id: ID!
  # Date when event happened at in ISO 8601 format.
  date: DateTime
  # Order event type.
  type: OrderEventsEnum
  # User who performed the action.
  user: User
  # Content of the event.
  message: String
  # Email of the customer.
  email: String
  # Type of an email sent to the customer.
  emailType: OrderEventsEmailsEnum
  # Amount of money.
  amount: Float
  # The payment ID from the payment gateway.
  paymentId: String
  # The payment gateway of the payment.
  paymentGateway: String
  # User-friendly number of an order.
  orderNumber: String
  # Number of an invoice related to the order.
  invoiceNumber: String
}

type OrderEventCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [OrderEventCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type OrderEventCountableEdge {
  # The item at the end of the edge.
  node: OrderEvent!
  # A cursor for use in pagination.
  cursor: String!
}

# An enumeration.
enum OrderEventsEmailsEnum {
  PAYMENT_CONFIRMATION
  ORDER_CONFIRMATION
  ORDER_CANCEL
  ORDER_REFUND
  FULFILLMENT_CONFIRMATION
  DIGITAL_LINKS
}

# An enumeration.
enum OrderEventsEnum {
  CANCELLED
  COMPLETED
  CREATED
  FULFILLED
  PAID
  PENDING
  MARKED_AS_PAID
  EMAIL_SENT
  PAYMENT_AUTHORIZED
  PAYMENT_CAPTURED
  PAYMENT_REFUNDED
  PAYMENT_VOIDED
  PAYMENT_FAILED
  EXTERNAL_SERVICE_NOTIFICATION
  INVOICE_REQUESTED
  INVOICE_GENERATED
  INVOICE_UPDATED
  INVOICE_SENT
  NOTE_ADDED
  OTHER
}

input OrderFilterInput {
  paymentStatus: [PaymentChargeStatusEnum]
  status: [OrderStatusFilter]
  account: String
  created: DateRangeInput
  search: String
}

# Mark order as manually paid.
type OrderMarkAsPaid {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Order marked as paid.
  order: Order
  orderErrors: [OrderError!]!
}

# Refund an order.
type OrderRefund {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A refunded order.
  order: Order
  orderErrors: [OrderError!]!
}

enum OrderSortField {
  # Sort orders by number.
  NUMBER
  # Sort orders by creation date.
  CREATION_DATE
  # Sort orders by account.
  ACCOUNT
  # Sort orders by payment.
  PAYMENT
  # Sort orders by fulfillment status.
  FULFILLMENT_STATUS
  # Sort orders by total.
  TOTAL
}

input OrderSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort orders by the selected field.
  field: OrderSortField!
}

# An enumeration.
enum OrderStatus {
  # The order was cancelled
  CANCELLED
  # The order was completed
  COMPLETED
  # The order was created
  CREATED
  # The order was fulfilled
  FULFILLED
  # The order was paid
  PAID
  # The order was pending
  PENDING
  # The order was manually marked as fully paid
  MARKED_AS_PAID
  # The email was sent
  EMAIL_SENT
  # The payment was authorized
  PAYMENT_AUTHORIZED
  # The payment was captured
  PAYMENT_CAPTURED
  # The payment was refunded
  PAYMENT_REFUNDED
  # The payment was voided
  PAYMENT_VOIDED
  # The payment was failed
  PAYMENT_FAILED
  # Notification from external service
  EXTERNAL_SERVICE_NOTIFICATION
  # An invoice was requested
  INVOICE_REQUESTED
  # An invoice was generated
  INVOICE_GENERATED
  # An invoice was updated
  INVOICE_UPDATED
  # An invoice was sent
  INVOICE_SENT
  # A note was added to the order
  NOTE_ADDED
  # An unknown order event containing a message
  OTHER
}

enum OrderStatusFilter {
  CANCELLED
  COMPLETED
  CREATED
  FULFILLED
  PAID
  PENDING
}

# Updates an order.
type OrderUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  orderErrors: [OrderError!]!
  order: Order
}

input OrderUpdateInput {
  # Billing address of the customer.
  billingAddress: AddressInput
  # Email address of the customer.
  userEmail: String
  # Shipping address of the customer.
  shippingAddress: AddressInput
}

# Void an order.
type OrderVoid {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A voided order.
  order: Order
  orderErrors: [OrderError!]!
}

# A static page that can be manually added by a shop operator through the dashboard.
type Page implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  title: String!
  summary: String!
  content: String!
  contentJson: JSONString!
  creationDate: DateTime!
  publicationDate: Date
  updateDate: Date!
  isPublished: Boolean!
  slug: String!
  # Returns translated page fields for the given language code.
  translation(
    # A language code to return the translation for page.
    languageCode: LanguageCodeEnum!
  ): PageTranslation
}

# Deletes pages.
type PageBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  pageErrors: [PageError!]!
}

# Publish pages.
type PageBulkPublish {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  pageErrors: [PageError!]!
}

type PageCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [PageCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type PageCountableEdge {
  # The item at the end of the edge.
  node: Page!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new page.
type PageCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  pageErrors: [PageError!]!
  page: Page
}

# Deletes a page.
type PageDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  pageErrors: [PageError!]!
  page: Page
}

type PageError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PageErrorCode!
}

# An enumeration.
enum PageErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

input PageFilterInput {
  search: String
}

# The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!
  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!
  # When paginating backwards, the cursor to continue.
  startCursor: String
  # When paginating forwards, the cursor to continue.
  endCursor: String
}

input PageInput {
  # Page internal name.
  slug: String
  # Page title.
  title: String
  # Page summary.
  summary: String
  # Page content. May consist of ordinary text, HTML and images.
  content: String
  # Page content in JSON format.
  contentJson: JSONString
  # Determines if page is visible in the storefront.
  isPublished: Boolean
  # Publication date. ISO 8601 standard.
  publicationDate: String
  # Search engine optimization fields.
  seo: SeoInput
}

enum PageSortField {
  # Sort pages by title.
  TITLE
  # Sort pages by slug.
  SLUG
  # Sort pages by visibility.
  VISIBILITY
  # Sort pages by creation date.
  CREATION_DATE
  # Sort pages by publication date.
  PUBLICATION_DATE
}

input PageSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort pages by the selected field.
  field: PageSortField!
}

type PageTranslatableContent implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  title: String!
  summary: String!
  content: String!
  contentJson: JSONString!
  # Returns translated page fields for the given language code.
  translation(
    # A language code to return the translation for page.
    languageCode: LanguageCodeEnum!
  ): PageTranslation
  # ('A static page that can be manually added by a site operator ', 'through the dashboard.')
  page: Page
}

# Creates/Updates translations for Page.
type PageTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  translationErrors: [TranslationError!]!
  page: PageTranslatableContent
}

type PageTranslation implements Node {
  seoTitle: String
  seoDescription: String
  # The ID of the object.
  id: ID!
  title: String!
  summary: String!
  content: String!
  contentJson: JSONString!
  # Translation language.
  language: LanguageDisplay!
}

input PageTranslationInput {
  seoTitle: String
  seoDescription: String
  title: String
  description: JSONString
  content: String
  contentJson: JSONString
}

# Updates an existing page.
type PageUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  pageErrors: [PageError!]!
  page: Page
}

# Change the password of the logged in user.
type PasswordChange {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A user instance with a new password.
  user: User
  accountErrors: [AccountError!]!
}

# Represents a payment of a given type.
type Payment implements Node {
  # The ID of the object.
  id: ID!
  gateway: String!
  isActive: Boolean!
  created: DateTime!
  modified: DateTime!
  token: String!
  order: Order
  billingEmail: String!
  accountIpAddress: String
  extraData: String!
  # Internal payment status.
  chargeStatus: PaymentChargeStatusEnum!
  # List of actions that can be performed in the current state of a payment.
  actions: [OrderAction]!
  # Total amount of the payment.
  total: Money
  # Total amount captured for this payment.
  capturedAmount: Money
  # Customer billing address.
  billingAddress: Address
  # List of all transactions within this payment.
  transactions: [Transaction]
  # Maximum amount of money that can be captured.
  availableCaptureAmount: Money
  # Maximum amount of money that can be refunded.
  availableRefundAmount: Money
  # The details of the card used for this payment.
  creditCard: CreditCard
}

# Captures the authorized payment amount.
type PaymentCapture {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Updated payment.
  payment: Payment
  paymentErrors: [PaymentError!]!
}

# An enumeration.
enum PaymentChargeStatusEnum {
  NOT_CHARGED
  PENDING
  PARTIALLY_CHARGED
  FULLY_CHARGED
  PARTIALLY_REFUNDED
  FULLY_REFUNDED
  REFUSED
  CANCELLED
}

type PaymentCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [PaymentCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type PaymentCountableEdge {
  # The item at the end of the edge.
  node: Payment!
  # A cursor for use in pagination.
  cursor: String!
}

type PaymentError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PaymentErrorCode!
}

# An enumeration.
enum PaymentErrorCode {
  BILLING_ADDRESS_NOT_SET
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
  PARTIAL_PAYMENT_NOT_ALLOWED
  PAYMENT_ERROR
  NOT_SUPPORTED_GATEWAY
}

# Available payment gateway backend with configuration necessary to setup client.
type PaymentGateway {
  # Payment gateway name.
  name: String!
  # Payment gateway ID.
  id: ID!
  # Payment gateway client configuration.
  config: [GatewayConfigLine!]!
  # Payment gateway supported currencies.
  currencies: [String]!
}

# Refunds the captured payment amount.
type PaymentRefund {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Updated payment.
  payment: Payment
  paymentErrors: [PaymentError!]!
}

# Confirms payment in a two-step process like 3D secure
type PaymentSecureConfirm {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Updated payment.
  payment: Payment
  paymentErrors: [PaymentError!]!
}

# Represents a payment source stored for user in payment gateway, such as credit card.
type PaymentSource {
  # Payment gateway name.
  gateway: String!
  # Stored credit card details if available.
  creditCardInfo: CreditCard
}

# Voids the authorized payment.
type PaymentVoid {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Updated payment.
  payment: Payment
  paymentErrors: [PaymentError!]!
}

# Represents a permission object in a friendly form.
type Permission {
  # Internal code for permission.
  code: PermissionEnum!
  # Describe action(s) allowed to do by permission.
  name: String!
}

# An enumeration.
enum PermissionEnum {
  MANAGE_USERS
  MANAGE_STAFF
  MANAGE_SERVICE_ACCOUNTS
  MANAGE_APPS
  MANAGE_BLOGS
  MANAGE_TICKETS
  MANAGE_PLUGINS
  MANAGE_MENUS
  MANAGE_PAGES
  MANAGE_PROFILES
  MANAGE_PRODUCTS
  MANAGE_CATEGORIES
  MANAGE_ORDERS
  MANAGE_SETTINGS
  MANAGE_TRANSLATIONS
}

# Create new permission group.
type PermissionGroupCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  permissionGroupErrors: [PermissionGroupError!]!
  group: Group
}

input PermissionGroupCreateInput {
  # List of permission code names to assign to this group.
  addPermissions: [PermissionEnum!]
  # List of users to assign to this group.
  addUsers: [ID!]
  # Group name.
  name: String!
}

# Delete permission group.
type PermissionGroupDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  permissionGroupErrors: [PermissionGroupError!]!
  group: Group
}

type PermissionGroupError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PermissionGroupErrorCode!
  # List of permissions which causes the error.
  permissions: [PermissionEnum!]
  # List of user IDs which causes the error.
  users: [ID!]
}

# An enumeration.
enum PermissionGroupErrorCode {
  ASSIGN_NON_STAFF_MEMBER
  DUPLICATED_INPUT_ITEM
  CANNOT_REMOVE_FROM_LAST_GROUP
  LEFT_NOT_MANAGEABLE_PERMISSION
  OUT_OF_SCOPE_PERMISSION
  OUT_OF_SCOPE_USER
  REQUIRED
  UNIQUE
}

input PermissionGroupFilterInput {
  search: String
}

enum PermissionGroupSortField {
  # Sort permission group accounts by name.
  NAME
}

input PermissionGroupSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort permission group by the selected field.
  field: PermissionGroupSortField!
}

# Update permission group.
type PermissionGroupUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  permissionGroupErrors: [PermissionGroupError!]!
  group: Group
}

input PermissionGroupUpdateInput {
  # List of permission code names to assign to this group.
  addPermissions: [PermissionEnum!]
  # List of users to assign to this group.
  addUsers: [ID!]
  # Group name.
  name: String
  # List of permission code names to unassign from this group.
  removePermissions: [PermissionEnum!]
  # List of users to unassign from this group.
  removeUsers: [ID!]
}

# Plugin.
type Plugin implements Node {
  id: ID!
  name: String!
  description: String!
  active: Boolean!
  configuration: [ConfigurationItem]
}

type PluginCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [PluginCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type PluginCountableEdge {
  # The item at the end of the edge.
  node: Plugin!
  # A cursor for use in pagination.
  cursor: String!
}

type PluginError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: PluginErrorCode!
}

# An enumeration.
enum PluginErrorCode {
  GRAPHQL_ERROR
  INVALID
  PLUGIN_MISCONFIGURED
  NOT_FOUND
  REQUIRED
  UNIQUE
}

input PluginFilterInput {
  active: Boolean
  search: String
}

enum PluginSortField {
  NAME
  IS_ACTIVE
}

input PluginSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort plugins by the selected field.
  field: PluginSortField!
}

# Update plugin configuration.
type PluginUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  plugin: Plugin
  pluginsErrors: [PluginError!]!
}

input PluginUpdateInput {
  # Indicates whether the plugin should be enabled.
  active: Boolean
  # Configuration of the plugin.
  configuration: [ConfigurationItemInput]
}

# Positive Decimal scalar implementation.
# Should be used in places where value must be positive.
scalar PositiveDecimal

# Company product.
type Product implements Node {
  seoTitle: String
  seoDescription: String
  creationDate: DateTime!
  publicationDate: Date
  updateDate: Date!
  isPublished: Boolean!
  # The ID of the object.
  id: ID!
  company: Company
  name: String!
  slug: String!
  description: String!
  descriptionJson: JSONString!
  hsCode: String!
  unitWeight: Float
  privateLabel: Boolean!
  isActive: Boolean!
  thumbnail(
    # Sizes of the product thumbnail.
    size: Int
  ): Image
  # Sizes of the product images.
  images: [ProductImage]
  # List of product prices.
  prices: [ProductPrice]
  # List of product videos.
  videos: [ProductVideo]
  # Product category.
  category: Category
}

# Activates a product.
type ProductActivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  product: Product
  productErrors: [ProductError!]!
}

enum ProductActivationStatus {
  ACTIVE
  INACTIVE
}

# Deletes company products.
type ProductBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

# Updates company products.
type ProductBulkUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  productErrors: [ProductError!]!
}

type ProductCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ProductCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ProductCountableEdge {
  # The item at the end of the edge.
  node: Product!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new product.
type ProductCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  product: Product
  productErrors: [ProductError!]!
}

# Deactivates a product.
type ProductDeactivate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productErrors: [ProductError!]!
  product: Product
}

# Deletes a product.
type ProductDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productErrors: [ProductError!]!
  product: Product
}

type ProductError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ProductErrorCode!
}

# An enumeration.
enum ProductErrorCode {
  ALREADY_EXISTS
  GRAPHQL_ERROR
  INVALID
  NOT_PRODUCTS_IMAGE
  NOT_FOUND
  REQUIRED
  UNIQUE
}

input ProductFilterInput {
  search: String
  status: ProductStatus
  isActive: ProductActivationStatus
  isPublished: ProductPublishedStatus
  dateCreated: DateRangeInput
}

# Company product images.
type ProductImage implements Node {
  # The ID of the object.
  id: ID!
  product: Product!
  image(
    # Sizes of the product image.
    size: Int
  ): Image
  ppoi: String!
  altText: String!
  order: Int!
}

type ProductImageCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ProductImageCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ProductImageCountableEdge {
  # The item at the end of the edge.
  node: ProductImage!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new product image.
type ProductImageCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productImage: ProductImage
  profileErrors: [ProductError!]!
}

# Deletes a product image.
type ProductImageDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProductError!]!
  productImage: ProductImage
}

input ProductImageInput {
  # Product image.
  image: Upload!
  # Product image alt text.
  altText: String
  # Product image ordering number.
  order: Int
}

# Updates an existing product image.
type ProductImageUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productImage: ProductImage
  profileErrors: [ProductError!]!
}

input ProductInput {
  # Product name.
  name: String
  # Product slug.
  slug: String
  # Product content (HTML/text).
  description: String
  # Product content (JSON).
  descriptionJson: JSONString
  # Product HS code.
  hsCode: String
  # Product category ID
  category: ID
  # Weight of the Product.
  unitWeight: WeightScalar
  # Determines if product private label is available.
  privateLabel: Boolean
  # Search engine optimization fields.
  seo: SeoInput
  # Determines if product is visible to customers.
  isPublished: Boolean
}

# Company product prices.
type ProductPrice implements Node {
  # The ID of the object.
  id: ID!
  product: Product!
  orderMin: Int!
  orderMax: Int!
  unitPrice: Float!
  currency: String!
}

type ProductPriceCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ProductPriceCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ProductPriceCountableEdge {
  # The item at the end of the edge.
  node: ProductPrice!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new product price.
type ProductPriceCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productPrice: ProductPrice
  profileErrors: [ProductError!]!
}

# Deletes a product price.
type ProductPriceDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProductError!]!
  productPrice: ProductPrice
}

input ProductPriceInput {
  # Minimum number of order for this product price.
  orderMin: Int
  # Maximum number of order for this product price.
  orderMax: Int
  # Cost price of the product.
  unitPrice: PositiveDecimal
  # Maximum number of order for this product price.
  currency: String
}

# Updates an existing product price.
type ProductPriceUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productPrice: ProductPrice
  profileErrors: [ProductError!]!
}

# Publishes a product.
type ProductPublish {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  product: Product
  productErrors: [ProductError!]!
}

enum ProductPublishedStatus {
  PUBLISHED
  HIDDEN
}

enum ProductSortField {
  # Sort products by slug.
  SLUG
  # Sort products by name.
  NAME
  # Sort products by date created.
  DATE_CREATED
}

input ProductSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort products by the selected field.
  field: ProductSortField!
}

enum ProductStatus {
  ACTIVE
  INACTIVE
  HIDDEN
  PUBLISHED
}

# Unpublishes a product.
type ProductUnpublish {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  product: Product
  productErrors: [ProductError!]!
}

# Updates an existing product.
type ProductUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  product: Product
  productErrors: [ProductError!]!
}

# Company product videos.
type ProductVideo implements Node {
  # The ID of the object.
  id: ID!
  product: Product!
  video: String!
  altText: String!
  order: Int!
}

type ProductVideoCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [ProductVideoCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type ProductVideoCountableEdge {
  # The item at the end of the edge.
  node: ProductVideo!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new product video.
type ProductVideoCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productVideo: ProductVideo
  profileErrors: [ProductError!]!
}

# Deletes a product video.
type ProductVideoDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProductError!]!
  productVideo: ProductVideo
}

input ProductVideoInput {
  # Product video.
  video: Upload!
  # Product video alt text.
  altText: String
  # Product video ordering number.
  order: Int
}

# Updates an existing product video.
type ProductVideoUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  productVideo: ProductVideo
  profileErrors: [ProductError!]!
}

enum ProfileActivationStatus {
  ACTIVE
  INACTIVE
}

type ProfileError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: ProfileErrorCode!
}

# An enumeration.
enum ProfileErrorCode {
  CONTACT_FILTER
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  SLUG_TAKEN
  UNIQUE
}

enum ProfilePublishedStatus {
  PUBLISHED
  HIDDEN
}

enum ProfileStatus {
  ACTIVE
  INACTIVE
  HIDDEN
  PUBLISHED
}

type Query {
  # Look up a webhook by ID.
  webhook(
    # ID of the webhook.
    id: ID!
  ): Webhook
  # List of webhooks.
  webhooks(
    # Sort webhooks.
    sortBy: WebhookSortingInput
    # Filtering options for webhooks.
    filter: WebhookFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): WebhookCountableConnection
    @deprecated(
      reason: "Use webhooks field on app(s) query instead. This field will be removed soon"
    )
  # List of all available webhook events.
  webhookEvents: [WebhookEvent]
  # Retrieve a sample payload for a given webhook event based on real data. It can
  # be useful for some integrations where sample payload is required.
  webhookSamplePayload(
    # Name of the requested event type.
    eventType: WebhookSampleEventTypeEnum!
  ): JSONString
  # Returns a list of all translatable items of a given kind.
  translations(
    # Kind of objects to retrieve.
    kind: TranslatableKinds!
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): TranslatableItemConnection
  translation(
    # ID of the object to retrieve.
    id: ID!
    # Kind of the object to retrieve.
    kind: TranslatableKinds!
  ): TranslatableItem
  # Return information about the site.
  site: Site!
  # Company by ID or slug.
  company(
    # ID of the company.
    id: ID
    # slug of the company.
    slug: String
  ): Company
  # List of companies.
  companies(
    # Filtering options for companies.
    filter: CompanyFilterInput
    # Sort companies.
    sortBy: CompanySortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CompanyCountableConnection
  # User company profiles.
  userCompany: Company
  # List of user company profiles.
  userCompanies: [Company]
  # Company representative by ID.
  representative(
    # ID of the company representative.
    id: ID
  ): Representative
  # List of company representatives.
  representatives(
    # ID of the profile for its representative.
    companyId: ID
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): RepresentativeCountableConnection
  # Company certificate by ID.
  certificate(
    # ID of the company certificate.
    id: ID
  ): Certificate
  # List of company certificates.
  certificates(
    # ID of the company for its certificates.
    companyId: ID
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CertificateCountableConnection
  # Company brochure by ID.
  brochure(
    # ID of the company brochure.
    id: ID
  ): Brochure
  # List of company brochures.
  brochures(
    # ID of the company for its brochures.
    companyId: ID
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): BrochureCountableConnection
  # Company video by ID.
  video(
    # ID of the company video.
    id: ID
  ): Video
  # List of company videos.
  videos(
    # ID of the company for its videos.
    companyId: ID
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): VideoCountableConnection
  # Company social responsibility by ID.
  socialResponsibility(
    # ID of the company social responsibility.
    id: ID
  ): SocialResponsibility
  # List of company social responsibilities.
  socialResponsibilities(
    # ID of the company for its social responsibilities.
    companyId: ID
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): SocialResponsibilityCountableConnection
  # Contact by ID.
  contact(
    # ID of the contact.
    id: ID
  ): Contact
  # List of contacts.
  contacts(
    # ID of the company for its contacts.
    companyId: ID
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ContactCountableConnection
  # Category by ID or name.
  category(
    # ID of the category.
    id: ID
    # name of the category.
    name: String
  ): Category
  # List of categories.
  categories(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): CategoryCountableConnection
  # Product by ID or slug.
  product(
    # ID of the product.
    id: ID
    # slug of the product.
    slug: String
  ): Product
  # List of products.
  products(
    # Filtering options for products.
    filter: ProductFilterInput
    # Sort products.
    sortBy: ProductSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductCountableConnection
  # Product price by ID.
  productPrice(
    # ID of the product price.
    id: ID
  ): ProductPrice
  # Product prices.
  productPrices(
    # ID of the product for its prices.
    productId: ID
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductPriceCountableConnection
  # Product image by ID.
  productImage(
    # ID of the product image.
    id: ID
  ): ProductImage
  # Product images.
  productImages(
    # ID of the product for its images.
    productId: ID
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductImageCountableConnection
  # Product video by ID.
  productVideo(
    # ID of the product video.
    id: ID
  ): ProductVideo
  # Product videos.
  productVideos(
    # ID of the product for its videos.
    productId: ID
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): ProductVideoCountableConnection
  # Look up a payment by ID.
  payment(
    # ID of the payment.
    id: ID!
  ): Payment
  # List of payments.
  payments(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): PaymentCountableConnection
  # Look up a page by ID or slug.
  page(
    # ID of the page.
    id: ID
    # The slug of the page.
    slug: String
  ): Page
  # List of the shop's pages.
  pages(
    # Sort pages.
    sortBy: PageSortingInput
    # Filtering options for pages.
    filter: PageFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): PageCountableConnection
  # List of activity events to display on homepage (at the moment it only contains order-events).
  homepageEvents(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): OrderEventCountableConnection
  # Look up an order by ID.
  order(
    # ID of an order.
    id: ID!
  ): Order
  # List of orders.
  orders(
    # Sort orders.
    sortBy: OrderSortingInput
    # Filtering options for orders.
    filter: OrderFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): OrderCountableConnection
  # Return the total sales amount from a specific period.
  ordersTotal(
    # A period of time.
    period: ReportingPeriod
  ): TaxedMoney
  # Look up an order by token.
  orderByToken(
    # The order's token.
    token: UUID!
  ): Order
  # Look up a navigation menu by ID or name.
  menu(
    # ID of the menu.
    id: ID
    # The menu's name.
    name: String
  ): Menu
  # List of the storefront's menus.
  menus(
    # Sort menus.
    sortBy: MenuSortingInput
    # Filtering options for menus.
    filter: MenuFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): MenuCountableConnection
  # Look up a menu item by ID.
  menuItem(
    # ID of the menu item.
    id: ID!
  ): MenuItem
  # List of the storefronts's menu items.
  menuItems(
    # Sort menus items.
    sortBy: MenuItemSortingInput
    # Filtering options for menu items.
    filter: MenuItemFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): MenuItemCountableConnection
  # Look up a plugin by ID.
  plugin(
    # ID of the plugin.
    id: ID!
  ): Plugin
  # List of plugins.
  plugins(
    # Filtering options for plugins.
    filter: PluginFilterInput
    # Sort plugins.
    sortBy: PluginSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): PluginCountableConnection
  # Look up a ticket by ID.
  ticket(
    # ID of the ticket.
    id: ID
  ): Ticket
  # List of user tickets.
  tickets(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): TicketCountableConnection
  # List of all tax rates available from tax gateway.
  taxTypes: [TaxType]
  # Look up a blog by ID or slug.
  blog(
    # ID of the blog.
    id: ID
    # The slug of the blog.
    slug: String
  ): Blog
  # List of the shop's blogs.
  blogs(
    # Sort blogs.
    sortBy: BlogSortingInput
    # Filtering options for blogs.
    filter: BlogFilterInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): BlogCountableConnection
  # List of all apps installations
  appsInstallations: [AppInstallation!]!
  # List of the apps.
  apps(
    # Filtering options for apps.
    filter: AppFilterInput
    # Sort apps.
    sortBy: AppSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): AppCountableConnection
  # Look up a app by ID.
  app(
    # ID of the app.
    id: ID!
  ): App
  # Returns address validation rules.
  addressValidationRules(
    # Two-letter ISO 3166-1 country code.
    countryCode: CountryCode!
    # Designation of a region, province or state.
    countryArea: String
    # City or a town name.
    city: String
    # Sublocality like a district.
    cityArea: String
  ): AddressValidationData
  # Look up an address by ID.
  address(
    # ID of an address.
    id: ID!
  ): Address
  # List of the shop's accounts.
  accounts(
    # Filtering options for accounts.
    filter: AccountFilterInput
    # Sort accounts.
    sortBy: UserSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): UserCountableConnection
  # List of permission groups.
  permissionGroups(
    # Filtering options for permission groups.
    filter: PermissionGroupFilterInput
    # Sort permission groups.
    sortBy: PermissionGroupSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): GroupCountableConnection
  # Look up permission group by ID.
  permissionGroup(
    # ID of the group.
    id: ID!
  ): Group
  # Return the currently authenticated user.
  me: User
  # List of the shop's staff users.
  staffUsers(
    # Filtering options for staff users.
    filter: StaffUserInput
    # Sort staff users.
    sortBy: UserSortingInput
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): UserCountableConnection
  # Look up a user by ID.
  user(
    # ID of the user.
    id: ID!
  ): User
  _entities(representations: [_Any]): [_Entity]
  _service: _Service
}

# Refresh JWT token. Mutation tries to take refreshToken from the input.If it
# fails it will try to take refreshToken from the http-only cookie -refreshToken.
# csrfToken is required when refreshToken is provided as a cookie.
type RefreshToken {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # JWT token, required to authenticate.
  token: String
  # A user instance.
  user: User
  accountErrors: [AccountError!]!
}

enum ReportingPeriod {
  TODAY
  THIS_MONTH
}

# Company Representative.
type Representative implements Node {
  # The ID of the object.
  id: ID!
  company: Company
  photo(
    # Sizes of the representative photo.
    size: Int
  ): Image
  photoAlt: String!
  name: String!
  position: String!
  linkedinUrl: String!
}

type RepresentativeCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [RepresentativeCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type RepresentativeCountableEdge {
  # The item at the end of the edge.
  node: Representative!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new representative.
type RepresentativeCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  representative: Representative
  profileErrors: [ProfileError!]!
}

# Deletes a representative.
type RepresentativeDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProfileError!]!
  representative: Representative
}

input RepresentativeInput {
  # Representative file.
  photo: Upload
  # The representative name of your company
  name: String
  # The representative position of your company
  position: String
  # The representative linkedin URL
  linkedinUrl: String
}

# Updates an existing ticket.
type RepresentativeUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  representative: Representative
  profileErrors: [ProfileError!]!
}

# Request email change of the logged in user.
type RequestEmailChange {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # A user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Sends an email with the account password modification link.
type RequestPasswordReset {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  accountErrors: [AccountError!]!
}

input SeoInput {
  # SEO title.
  title: String
  # SEO description.
  description: String
}

# Sets the user's password from the token sent by email using the RequestPasswordReset mutation.
type SetPassword {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # JWT token, required to authenticate.
  token: String
  # JWT refresh token, required to re-generate access token.
  refreshToken: String
  # CSRF token required to re-generate access token.
  csrfToken: String
  # A user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Represents a site resource containing general site data and configuration.
type Site {
  # List of available payment gateways.
  availablePaymentGateways(
    # A currency for which gateways will be returned.
    currency: String
  ): [PaymentGateway!]!
  # Customer's geolocalization data.
  geolocalization: Geolocalization
  # List of configured authorization keys. Authorization keys are used to enable
  # third-party OAuth authorization (currently Facebook or Google).
  authorizationKeys: [AuthorizationKey]!
  # List of countries available in the site.
  countries(
    # A language code to return the translation for.
    languageCode: LanguageCodeEnum
  ): [CountryDisplay!]!
  # List of available currencies.
  currencies: [String]!
  # Site's default currency.
  defaultCurrency: String!
  # Site's default country.
  defaultCountry: CountryDisplay
  # Default site's email sender's name.
  defaultMailSenderName: String
  # Default site's email sender's address.
  defaultMailSenderAddress: String
  # Site's description.
  description: String
  # Site's domain data.
  domain: Domain!
  # List of the sites's supported languages.
  languages: [LanguageDisplay]!
  # Site's name.
  name: String!
  # Site's navigation.
  navigation: Navigation
  # List of available permissions.
  permissions: [Permission]!
  # List of possible phone prefixes.
  phonePrefixes: [String]!
  # Header text.
  headerText: String
  # Include taxes in prices.
  includeTaxesInPrices: Boolean!
  # Display prices with tax in store.
  displayGrossPrices: Boolean!
  # Returns translated site fields for the given language code.
  translation(
    # A language code to return the translation for site.
    languageCode: LanguageCodeEnum!
  ): SiteTranslation
  # Company address.
  companyAddress: Address
  # URL of a view where customers can set their password.
  accountSetPasswordUrl: String
  # List of staff notification recipients.
  staffNotificationRecipients: [StaffNotificationRecipient]
}

# Update the site's address. If the `null` value is passed, the currently selected address will be deleted.
type SiteAddressUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Updated site.
  site: Site
  siteErrors: [SiteError!]!
}

input SiteDomainInput {
  # Domain name for site.
  domain: String
  # Site site name.
  name: String
}

# Updates site domain of the site.
type SiteDomainUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Updated site.
  site: Site
  siteErrors: [SiteError!]!
}

type SiteError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: SiteErrorCode!
}

# An enumeration.
enum SiteErrorCode {
  ALREADY_EXISTS
  CANNOT_FETCH_TAX_RATES
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

# Fetch tax rates.
type SiteFetchTaxRates {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Updated site.
  site: Site
  siteErrors: [SiteError!]!
}

input SiteSettingsInput {
  # Header text.
  headerText: String
  # SEO description.
  description: String
  # Include taxes in prices.
  includeTaxesInPrices: Boolean
  # Display prices with tax in store.
  displayGrossPrices: Boolean
  # Default email sender's name.
  defaultMailSenderName: String
  # Default email sender's address.
  defaultMailSenderAddress: String
  # URL of a view where accounts can set their password.
  accountSetPasswordUrl: String
}

# Creates/Updates translations for Site Settings.
type SiteSettingsTranslate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Updated site.
  site: Site
  translationErrors: [TranslationError!]!
}

input SiteSettingsTranslationInput {
  headerText: String
  description: String
}

# Updates site settings.
type SiteSettingsUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Updated site.
  site: Site
  siteErrors: [SiteError!]!
}

type SiteTranslation implements Node {
  # The ID of the object.
  id: ID!
  headerText: String!
  description: String!
  # Translation language.
  language: LanguageDisplay!
}

# Company social responsibilities.
type SocialResponsibility implements Node {
  # The ID of the object.
  id: ID!
  company: Company
  name: String!
  video: String!
  youtubeUrl: String!
  image: String!
  brochure: String!
  description: String!
  order: Int!
}

type SocialResponsibilityCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [SocialResponsibilityCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type SocialResponsibilityCountableEdge {
  # The item at the end of the edge.
  node: SocialResponsibility!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new social responsibility.
type SocialResponsibilityCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  socialResponsibility: SocialResponsibility
  profileErrors: [ProfileError!]!
}

# Deletes a social responsibility.
type SocialResponsibilityDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProfileError!]!
  socialResponsibility: SocialResponsibility
}

input SocialResponsibilityInput {
  # Company social responsibility title.
  title: String
  # Company social responsibility video file.
  video: Upload
  # The youtube url of company social responsibility.
  youtubeUrl: String
  # Company social responsibility image file.
  image: Upload
  # Company social responsibility brochure file.
  brochure: Upload
  # The description of company social responsibility.
  description: String
  # The order of your social responsibility.
  order: Int
}

# Updates an existing social responsibility.
type SocialResponsibilityUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  socialResponsibility: SocialResponsibility
  profileErrors: [ProfileError!]!
}

# Deletes staff users.
type StaffBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  staffErrors: [StaffError!]!
}

# Creates a new staff user.
type StaffCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  staffErrors: [StaffError!]!
  user: User
}

input StaffCreateInput {
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # The unique email address of the user.
  email: String
  # User account is active.
  isActive: Boolean
  # A note about the user.
  note: String
  # List of permission group IDs to which user should be assigned.
  addGroups: [ID!]
  # URL of a view where users should be redirected to set the password. URL in RFC 1808 format.
  redirectUrl: String
}

# Deletes a staff user.
type StaffDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  staffErrors: [StaffError!]!
  user: User
}

type StaffError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: AccountErrorCode!
  # List of permissions which causes the error.
  permissions: [PermissionEnum!]
  # List of permission group IDs which cause the error.
  groups: [ID!]
  # List of user IDs which causes the error.
  users: [ID!]
}

enum StaffMemberStatus {
  ACTIVE
  DEACTIVATED
}

# Represents a recipient of email notifications send by Saleor, such as
# notifications about new orders. Notifications can be assigned to staff users or
# arbitrary email addresses.
type StaffNotificationRecipient implements Node {
  # Returns a user subscribed to email notifications.
  user: User
  # Determines if a notification active.
  active: Boolean
  # The ID of the object.
  id: ID!
  # Returns email address of a user subscribed to email notifications.
  email: String
}

# Creates a new staff notification recipient.
type StaffNotificationRecipientCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  siteErrors: [SiteError!]!
  staffNotificationRecipient: StaffNotificationRecipient
}

# Delete staff notification recipient.
type StaffNotificationRecipientDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  siteErrors: [SiteError!]!
  staffNotificationRecipient: StaffNotificationRecipient
}

input StaffNotificationRecipientInput {
  # The ID of the user subscribed to email notifications..
  user: ID
  # Email address of a user subscribed to email notifications.
  email: String
  # Determines if a notification active.
  active: Boolean
}

# Updates a staff notification recipient.
type StaffNotificationRecipientUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  siteErrors: [SiteError!]!
  staffNotificationRecipient: StaffNotificationRecipient
}

# Updates an existing staff user.
type StaffUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  staffErrors: [StaffError!]!
  user: User
}

input StaffUpdateInput {
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # The unique email address of the user.
  email: String
  # User account is active.
  isActive: Boolean
  # A note about the user.
  note: String
  # List of permission group IDs to which user should be assigned.
  addGroups: [ID!]
  # List of permission group IDs from which user should be unassigned.
  removeGroups: [ID!]
}

input StaffUserInput {
  status: StaffMemberStatus
  search: String
}

# Represents a monetary value with taxes. In cases where taxes were not applied, net and gross values will be equal.
type TaxedMoney {
  # Currency code.
  currency: String!
  # Amount of money including taxes.
  gross: Money!
  # Amount of money without taxes.
  net: Money!
  # Amount of taxes.
  tax: Money!
}

# Representation of tax types fetched from tax gateway.
type TaxType {
  # Description of the tax type.
  description: String
  # External tax code used to identify given tax group.
  taxCode: String
}

# User helpdesk ticket.
type Ticket implements Node {
  # The ID of the object.
  id: ID!
  user: User
  type: TicketType!
  subject: String!
  content: String!
  creationDate: DateTime!
  notes: String!
  status: TicketStatus!
  updateDate: DateTime!
}

# Deletes tickets.
type TicketBulkDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  helpdeskErrors: [HelpdeskError!]!
}

# Updates tickets.
type TicketBulkUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  helpdeskErrors: [HelpdeskError!]!
}

type TicketCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [TicketCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type TicketCountableEdge {
  # The item at the end of the edge.
  node: Ticket!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new ticket.
type TicketCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  ticket: Ticket
  helpdeskErrors: [HelpdeskError!]!
}

# Deletes a ticket.
type TicketDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  helpdeskErrors: [HelpdeskError!]!
  ticket: Ticket
}

input TicketInput {
  # Ticket type.
  type: String
  # Ticket subject.
  subject: String
  # Ticket content.
  content: String
  # Ticket notes.
  note: String
  # Ticket status.
  status: String
}

# An enumeration.
enum TicketStatus {
  # New
  NEW
  # On Progress
  ON_PROGRESS
  # Completed
  COMPLETED
  # Other
  OTHER
}

# An enumeration.
enum TicketType {
  # Support
  SUPPORT
  # Feedback
  FEEDBACK
  # Recommendation
  RECOMMENDATION
  # New Feature Request
  NEW_FEATURE_REQUEST
  # Other
  OTHER
}

# Updates an existing ticket.
type TicketUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  ticket: Ticket
  helpdeskErrors: [HelpdeskError!]!
}

# An object representing a single payment.
type Transaction implements Node {
  # The ID of the object.
  id: ID!
  created: DateTime!
  token: String!
  kind: TransactionKind!
  isSuccess: Boolean!
  error: TransactionError
  gatewayResponse: JSONString!
  # Total amount of the transaction.
  amount: Money
}

# An enumeration.
enum TransactionError {
  # incorrect_number
  TRANSACTIONERROR_INCORRECT_NUMBER
  # invalid_number
  TRANSACTIONERROR_INVALID_NUMBER
  # incorrect_cvv
  TRANSACTIONERROR_INCORRECT_CVV
  # invalid_cvv
  TRANSACTIONERROR_INVALID_CVV
  # incorrect_zip
  TRANSACTIONERROR_INCORRECT_ZIP
  # incorrect_address
  TRANSACTIONERROR_INCORRECT_ADDRESS
  # invalid_expiry_date
  TRANSACTIONERROR_INVALID_EXPIRY_DATE
  # expired
  TRANSACTIONERROR_EXPIRED
  # processing_error
  TRANSACTIONERROR_PROCESSING_ERROR
  # declined
  TRANSACTIONERROR_DECLINED
}

# An enumeration.
enum TransactionKind {
  # Authorization
  AUTH
  # Pending
  PENDING
  # Action to confirm
  ACTION_TO_CONFIRM
  # Refund
  REFUND
  # Refund in progress
  REFUND_ONGOING
  # Capture
  CAPTURE
  # Void
  VOID
  # Confirm
  CONFIRM
  # Cancel
  CANCEL
}

union TranslatableItem =
    BlogTranslatableContent
  | PageTranslatableContent
  | MenuItemTranslatableContent
type TranslatableItemConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [TranslatableItemEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type TranslatableItemEdge {
  # The item at the end of the edge.
  node: TranslatableItem!
  # A cursor for use in pagination.
  cursor: String!
}

enum TranslatableKinds {
  BLOG
  PAGE
  PROFILE
  MENU_ITEM
}

type TranslationError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: TranslationErrorCode!
}

# An enumeration.
enum TranslationErrorCode {
  GRAPHQL_ERROR
  NOT_FOUND
  REQUIRED
}

input UpdateInvoiceInput {
  # Invoice number
  number: String
  # URL of an invoice to download.
  url: String
}

# Updates metadata of an object.
type UpdateMetadata {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadata
}

# Updates private metadata of an object.
type UpdatePrivateMetadata {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  metadataErrors: [MetadataError!]!
  item: ObjectWithMetadata
}

# Variables of this type must be set to null in mutations. They will be replaced
# with a filename from a following multipart part containing a binary file. See:
# https://github.com/jaydenseric/graphql-multipart-request-spec.
scalar Upload

# Represents user data.
type User implements Node & ObjectWithMetadata {
  # The ID of the object.
  id: ID!
  lastLogin: DateTime
  email: String!
  userId: String!
  firstName: String!
  lastName: String!
  isStaff: Boolean!
  isActive: Boolean!
  # A note about the customer.
  note: String
  dateJoined: DateTime!
  defaultShippingAddress: Address
  defaultBillingAddress: Address
  # List of private metadata items.Requires proper staff permissions to access.
  privateMetadata: [MetadataItem]!
  # List of public metadata items. Can be accessed without permissions.
  metadata: [MetadataItem]!
  # List of all user's addresses.
  addresses: [Address]
  # List of user's orders.
  orders(
    # Return the elements in the list that come before the specified cursor.
    before: String
    # Return the elements in the list that come after the specified cursor.
    after: String
    # Return the first n elements from the list.
    first: Int
    # Return the last n elements from the list.
    last: Int
  ): OrderCountableConnection
  # List of user's permissions.
  userPermissions: [UserPermission]
  # List of user's permission groups.
  permissionGroups: [Group]
  # List of user's permission groups which user can manage.
  editableGroups: [Group]
  avatar(
    # Size of the avatar.
    size: Int
  ): Image
  # List of events associated with the user.
  events: [AccountEvent]
  # List of stored payment sources.
  storedPaymentSources: [PaymentSource]
}

# Deletes a user avatar. Only for staff members.
type UserAvatarDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Create a user avatar. Only for staff members. This mutation must be sent as a
# `multipart` request. More detailed specs of the upload format can be found here:
# https://github.com/jaydenseric/graphql-multipart-request-spec
type UserAvatarUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # An updated user instance.
  user: User
  accountErrors: [AccountError!]!
}

# Activate or deactivate users.
type UserBulkSetActive {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # Returns how many objects were affected.
  count: Int!
  accountErrors: [AccountError!]!
}

type UserCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [UserCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type UserCountableEdge {
  # The item at the end of the edge.
  node: User!
  # A cursor for use in pagination.
  cursor: String!
}

input UserCreateInput {
  # Billing address of the account.
  defaultBillingAddress: AddressInput
  # Shipping address of the account.
  defaultShippingAddress: AddressInput
  # Given name.
  firstName: String
  # Family name.
  lastName: String
  # The unique email address of the user.
  email: String
  # User account is active.
  isActive: Boolean
  # A note about the user.
  note: String
  # URL of a view where users should be redirected to set the password. URL in RFC 1808 format.
  redirectUrl: String
}

type UserPermission {
  # Internal code for permission.
  code: PermissionEnum!
  # Describe action(s) allowed to do by permission.
  name: String!
  # List of user permission groups which contains this permission.
  sourcePermissionGroups(
    # ID of user whose groups should be returned.
    userId: ID!
  ): [Group!]
}

enum UserSortField {
  # Sort users by first name.
  FIRST_NAME
  # Sort users by last name.
  LAST_NAME
  # Sort users by email.
  EMAIL
  # Sort users by date joined.
  DATE_JOINED
  # Sort users by last login.
  LAST_LOGIN
}

input UserSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort users by the selected field.
  field: UserSortField!
}

scalar UUID

# Represents a VAT rate for a country.
type VAT {
  # Country code.
  countryCode: String!
  # Standard VAT rate in percent.
  standardRate: Float
}

# Verify JWT token.
type VerifyToken {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  # User assigned to token.
  user: User
  # Determine if token is valid or not.
  isValid: Boolean!
  # JWT payload.
  payload: GenericScalar
  accountErrors: [AccountError!]!
}

# Company videos.
type Video implements Node {
  # The ID of the object.
  id: ID!
  company: Company
  video: String!
  youtubeUrl: String!
  name: String!
  description: String!
  order: Int!
}

type VideoCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [VideoCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type VideoCountableEdge {
  # The item at the end of the edge.
  node: Video!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new video.
type VideoCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  video: Video
  profileErrors: [ProfileError!]!
}

# Deletes a video.
type VideoDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  profileErrors: [ProfileError!]!
  video: Video
}

input VideoInput {
  # Company video file.
  video: Upload
  # The youtube url of company video.
  youtubeUrl: String
  # The description of company video.
  description: String
  # The order of your video.
  order: Int
}

# Updates an existing ticket.
type VideoUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  video: Video
  profileErrors: [ProfileError!]!
}

# Webhook.
type Webhook implements Node {
  name: String!
  targetUrl: String!
  isActive: Boolean!
  secretKey: String
  # The ID of the object.
  id: ID!
  # List of webhook events.
  events: [WebhookEvent!]!
  app: App!
}

type WebhookCountableConnection {
  # Pagination data for this connection.
  pageInfo: PageInfo!
  edges: [WebhookCountableEdge!]!
  # A total count of items in the collection.
  totalCount: Int
}

type WebhookCountableEdge {
  # The item at the end of the edge.
  node: Webhook!
  # A cursor for use in pagination.
  cursor: String!
}

# Creates a new webhook subscription.
type WebhookCreate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  webhookErrors: [WebhookError!]!
  webhook: Webhook
}

input WebhookCreateInput {
  # The name of the webhook.
  name: String
  # The url to receive the payload.
  targetUrl: String
  # The events that webhook wants to subscribe. The CHECKOUT_QUANTITY_CHANGED is depreacted. It will be removed in Saleor 3.0
  events: [WebhookEventTypeEnum]
  # ID of the app to which webhook belongs.
  app: ID
  # Determine if webhook will be set active or not.
  isActive: Boolean
  # The secret key used to create a hash signature with each payload.
  secretKey: String
}

# Deletes a webhook subscription.
type WebhookDelete {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  webhookErrors: [WebhookError!]!
  webhook: Webhook
}

type WebhookError {
  # Name of a field that caused the error. A value of `null` indicates that the
  # error isn't associated with a particular field.
  field: String
  # The error message.
  message: String
  # The error code.
  code: WebhookErrorCode!
}

# An enumeration.
enum WebhookErrorCode {
  GRAPHQL_ERROR
  INVALID
  NOT_FOUND
  REQUIRED
  UNIQUE
}

# Webhook event.
type WebhookEvent {
  # Internal name of the event type.
  eventType: WebhookEventTypeEnum!
  # Display name of the event.
  name: String!
}

# An enumeration.
enum WebhookEventTypeEnum {
  ANY_EVENTS
  ACCOUNT_CREATED
  INVOICE_REQUESTED
  INVOICE_DELETED
  INVOICE_SENT
  ORDER_CREATED
  ORDER_PAID
  ORDER_UPDATED
  ORDER_CANCELLED
}

input WebhookFilterInput {
  search: String
  isActive: Boolean
}

# An enumeration.
enum WebhookSampleEventTypeEnum {
  ACCOUNT_CREATED
  INVOICE_REQUESTED
  INVOICE_DELETED
  INVOICE_SENT
  ORDER_CREATED
  ORDER_PAID
  ORDER_UPDATED
  ORDER_CANCELLED
}

enum WebhookSortField {
  # Sort webhooks by name.
  NAME
  # Sort webhooks by target url.
  TARGET_URL
  # Sort webhooks by app.
  APP
}

input WebhookSortingInput {
  # Specifies the direction in which to sort products.
  direction: OrderDirection!
  # Sort webhooks by the selected field.
  field: WebhookSortField!
}

# Updates a webhook subscription.
type WebhookUpdate {
  # List of errors that occurred executing the mutation.
  errors: [Error!]!
    @deprecated(
      reason: "Use typed errors with error codes. It will be updated soon."
    )
  webhookErrors: [WebhookError!]!
  webhook: Webhook
}

input WebhookUpdateInput {
  # The new name of the webhook.
  name: String
  # The url to receive the payload.
  targetUrl: String
  # The events that webhook wants to subscribe.
  events: [WebhookEventTypeEnum]
  # ID of the app to which webhook belongs.
  app: ID
  # Determine if webhook will be set active or not.
  isActive: Boolean
  # Use to create a hash signature with each payload.
  secretKey: String
}

scalar WeightScalar

